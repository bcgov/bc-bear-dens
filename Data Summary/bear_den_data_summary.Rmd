---
title: "Bear Den Data Summary"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ['xaringan-themer.css', 'custom.css']
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
editor_options: 
  chunk_output_type: console
---

```{r xaringan-themer, include = FALSE, warning = FALSE}
library(xaringanthemer)
style_solarized_light(header_color = "#859900")
```

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)

# Global knitr options
knitr::opts_chunk$set(warning = FALSE, # don't print code warnings in slides 
                      message = FALSE, # don't print code messages in slides
                      echo = FALSE, # don't print the code itself in any of the slides (unless manually overridden)
                      fig.width = 9, # make default figure width 9"
                      fig.align='center', # center align any figures
                      dev = "svg", # make any plots "svg" format (rather than PNG or JPEG for example)
                      dev.args = list(bg = "transparent") # make the background of all plots transparent
                      )

# Analysis options
den_status_strict <- FALSE # should the first record of "Active recently (0-4 seasons)" be counted as "Active"? TRUE or FALSE. FALSE = we use the first record in our models. As it stands, it makes no difference to our results.

# Load packages
library(targets)  # load up data targets
library(sf)       # spatial manipulation
library(leaflet)  # interactive map
library(dplyr)    # data manipulation
library(magrittr) # data manipulation
library(ggplot2)  # plotting
library(ggsignif) # plotting significance/t-test/wilcox test on boxplots
library(khroma)   # plotting color schemes
library(ggmosaic) # mosaic plot
library(glmmTMB)  # modeling

# Read in tokens
# For this specific markdown file, we need the 'jawg_token' to load
# the nice basemap for the interactive map.
withr::with_dir(rprojroot::find_root('_targets.R'), source("temp/token.R"))

# Load targets
# Since this markdown file isn't actually part of the targets
# pipeline, you need this weird workaround to load a target:
# https://github.com/ropensci/targets/issues/230

# dens = dens metadata (with no field visit info attached)
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(dens))

# f = field visits table (with no den metadata attached)
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(f))

# f_analysis = field visits data, rearranged such that the current year's
# den status is matched to *the previous year's* forestry data
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(f_analysis))

# prop_1km = proportion forested within 1.5km
prop_1km <- withr::with_dir(rprojroot::find_root('_targets.R'),
                            tar_read(prct_age_class_1.5km)) # use `tar_read` when you want to read a target but assign it to a new object name in the R environment
# Drop a few dupe records - they're from 3 dens that were visited twice
# within one year, so they each got an extra row in `prop_1km`
prop_1km <- dplyr::select(prop_1km, -sample_id) # we'll use den_id + year to merge
prop_1km <- unique(prop_1km)
# Bin proportion forested data into groups (sort of ~young, old, medium, very old)
prop_1km$lt_3 <- rowSums(prop_1km[,c("age_class_1", "age_class_2")])
prop_1km$gt_3 <- rowSums(prop_1km[,6:12])
prop_1km$three_to_7 <- rowSums(prop_1km[,6:10])
prop_1km$gt_8 <- rowSums(prop_1km[,c("age_class_8", "age_class_9")])

# road_density = road density around each den
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(road_density))
# Drop a few dupe records - they're from 3 dens that were visited twice
# within one year, so they each got an extra row in `prop_1km`
road_density <- dplyr::select(road_density, -sample_id) # we'll use den_id + year to merge
road_density <- unique(road_density)

# Define list of "for sure dens"
for_sure_dens <- c("Active in last denning season", 
                   "Not active in last season",
                   "Not active in last season, but recent use (1-4 seasons)",
                   "Not active in last season, no recent use (>4 seasons)",
                   "No recent evidence of use (>4 seasons)")
```

```{r dens prep, include = FALSE}
# Wrap this up into `clean_bears` func at some point
# Coerce factors
factors <- c("struct_stage", "age_class", "slope_position", "den_type", "den_tree_species", "district")
dens %<>% mutate_at(factors, factor)
# Remove 999
dens %<>%
  mutate(across(where(is.numeric), ~replace(., . == 999, NA)),
         across(where(is.numeric), ~replace(., . == -999, NA)))

# Add latitude, longitude cols to data
dens <- st_transform(dens, 3005) # to BC Albers projection
dens <- cbind(dens, st_coordinates(dens))
names(dens)[grep("X", names(dens))] <- "longitude" # technically easting/northing with BC Albers but shhh
names(dens)[grep("Y", names(dens))] <- "latitude"

# Assign either VI or HG to data, to examine by island
dens$region <- ifelse(dens$latitude > 800000, "HG", "VI")

# Drop any dens not present in the field visits
dens <- dens[dens$den_id %in% f$den_id, ]
```

```{r f prep, include = FALSE}
# Rename forestry columns to more consistent/easier to use names
f <- dplyr::rename(f,
              "nearest_tree_m" = "distance_nearest_tree_field",
              "f_prop_forest_60m" = "proportion_forested_field",
              "v_prop_forest_60m" = "proportion_forested",
              "f_dist_lt40" = "distance_less40yr_forest_field", 
              "v_dist_lt40" = "v_distance_less40yr_forest",
              "f_dist_gt40" = "distance_grtr40yr_forest_field", 
              "v_dist_gt40" = "v_distance_grtr40year_forest", 
              "f_dist_road" = "distance_nearest_road", 
              "v_dist_road" = "v_distance_nearest_road",
              "windthrow_prct" = "proportion_tree_windthrown", 
              "windthrow_code" = "x_windthrow_code")

# Take log of vars of interest
f$log_dist_lt40 <- log(f$f_dist_lt40 + 1)
f$log_dist_gt40 <- log(f$f_dist_gt40 + 1)
f$log_dist_road <- log(f$f_dist_road + 1)

# Make just one 'distance from edge' variable
f$dist_from_edge <- ifelse(f$f_dist_lt40 > 0, f$f_dist_lt40, f$f_dist_gt40)
f$log_dist_from_edge <- log(f$dist_from_edge + 1)

# Next, say if it's in old, new, or edge of forest.
f <- f |> dplyr::mutate(f_dist_lt40 = round(f_dist_lt40, 0),
                        f_dist_gt40 = round(f_dist_gt40, 0),
                        age = dplyr::case_when((f_dist_lt40 == f_dist_gt40) ~ "on_edge",
                                         (f_dist_lt40 > f_dist_gt40) ~ "within_old",
                                         (f_dist_lt40 < f_dist_gt40) ~ "within_young"))

# Add a `den_status_binary` column
f <- f |> dplyr::mutate(den_status_binary = dplyr::case_when(grepl("No", den_status) ~ "Not Active",
                                                     den_status %in% c("Active in last denning season", "Currently active") ~ "Active",
                                                     den_status == "Obsolete" ~ "Obsolete",
                                                     den_status == "Unknown" ~ "Unknown",
                                                     TRUE ~ "Unknown"))

# If "Active recently (0-4 seasons)" is the very first data point, 
# change it to "Active". 
f <- f |>
  dplyr::arrange(den_id, date_inspected) |>
  dplyr::group_by(den_id) |>
  dplyr::mutate(cumulative_visit = cumsum(!is.na(den_id))) |>
  dplyr::mutate(den_status_binary = ifelse(cumulative_visit == 1 & den_status == "Active recently (0-4 seasons)",
                                           "Active",
                                           den_status_binary))

# Double check our categories
unique(f[,c("den_status", "den_status_binary")]) |> 
  dplyr::arrange(den_status_binary) |>
  knitr::kable()

# Add a column indicating N active and whether or not the den was 
# ever active
f <- f |> 
  dplyr::group_by(den_id) |>
  dplyr::mutate(active_n = sum(den_status_binary == "Active")) |>
  dplyr::mutate(ever_active_yn = active_n > 0)

# Add a `year` column
f$year <- lubridate::year(f$date_inspected)

# Merge in landscape level variables

# Merge landscape scale forestry metrics with the f dataset
# Merge % age class to `f`
f <- merge(f, prop_1km, by = c("den_id", "year"), all.x = TRUE)

# Note the all.x = TRUE. If the den isn't in
# the road density df, the road density is 0.
f <- merge(f, road_density, 
                    by = c("den_id", "year"), # again, merging GIS forestry data for the year PRIOR to the den status year
                    all.x = TRUE) # all.x = TRUE is necessary if there's no roads (thus NULL road density)

f$road_density_m2 <- ifelse(is.na(f$road_density_m2), 0, f$road_density_m2)

```


```{r f_analysis prep, include = FALSE}
# Rename forestry columns to more consistent/easier to use names
f_analysis <- dplyr::rename(f_analysis,
              "nearest_tree_m" = "distance_nearest_tree_field",
              "f_prop_forest_60m" = "proportion_forested_field",
              "v_prop_forest_60m" = "proportion_forested",
              "f_dist_lt40" = "distance_less40yr_forest_field", 
              "v_dist_lt40" = "v_distance_less40yr_forest",
              "f_dist_gt40" = "distance_grtr40yr_forest_field", 
              "v_dist_gt40" = "v_distance_grtr40year_forest", 
              "f_dist_road" = "distance_nearest_road", 
              "v_dist_road" = "v_distance_nearest_road",
              "windthrow_prct" = "proportion_tree_windthrown", 
              "windthrow_code" = "x_windthrow_code")

# Take log of vars of interest
f_analysis$log_dist_lt40 <- log(f_analysis$v_dist_lt40 + 1)
f_analysis$log_dist_gt40 <- log(f_analysis$v_dist_gt40 + 1)
f_analysis$log_dist_road <- log(f_analysis$v_dist_road + 1)

# Next, make just one 'distance from edge' variable
f_analysis$dist_from_edge <- ifelse(f_analysis$v_dist_lt40 > 0, f_analysis$v_dist_lt40, f_analysis$v_dist_gt40)
f_analysis$log_dist_from_edge <- log(f_analysis$dist_from_edge + 1)

# Next, say if it's in old, new, or edge of forest.
f_analysis <- f_analysis |> dplyr::mutate(v_dist_lt40 = round(v_dist_lt40, 0),
                              v_dist_gt40 = round(v_dist_gt40, 0),
                              age = dplyr::case_when((v_dist_lt40 == v_dist_gt40) ~ "on_edge",
                                               (v_dist_lt40 > v_dist_gt40) ~ "within_old",
                                               (v_dist_lt40 < v_dist_gt40) ~ "within_young"))

# Add a `den_status_binary` column
f_analysis <- f_analysis |> dplyr::mutate(den_status_binary = dplyr::case_when(grepl("No", den_status) ~ "Not Active",
                                                     den_status %in% c("Active in last denning season", "Currently active") ~ "Active",
                                                     den_status == "Obsolete" ~ "Obsolete",
                                                     den_status == "Unknown" ~ "Unknown",
                                                     TRUE ~ "Unknown"))

if (den_status_strict == FALSE) {
  # If "Active recently (0-4 seasons)" is the very first data point, 
  # change it to "Active". 
  f_analysis <- f_analysis |>
    dplyr::arrange(den_id, date_inspected_den) |>
    dplyr::group_by(den_id) |>
    dplyr::mutate(cumulative_visit = cumsum(!is.na(den_id))) |>
    dplyr::mutate(den_status_binary = ifelse(cumulative_visit == 1 & den_status == "Active recently (0-4 seasons)",
                                             "Active",
                                             den_status_binary)) 
}

# Add a column indicating N active and whether or not the den was 
# ever active
f_analysis <- f_analysis |> 
  dplyr::group_by(den_id) |>
  dplyr::mutate(active_n = sum(den_status_binary == "Active")) |>
  dplyr::mutate(ever_active_yn = active_n > 0)

# Merge spatial/static den data with analysis subset of field visits
f_analysis <- merge(dens, f_analysis, by = "den_id")

# Merge landscape scale forestry metrics with the f_analysis dataset
# Merge % age class to `f_analysis`
f_analysis <- merge(f_analysis, prop_1km, by = c("den_id", "year"), all.x = TRUE)

# Note the all.x = TRUE. If the den isn't in
# the road density df, the road density is 0.
f_analysis <- merge(f_analysis, road_density, 
                    by = c("den_id", "year"), # again, merging GIS forestry data for the year PRIOR to the den status year
                    all.x = TRUE) # all.x = TRUE is necessary if there's no roads (thus NULL road density)

f_analysis$road_density_m2 <- ifelse(is.na(f_analysis$road_density_m2), 0, f_analysis$road_density_m2)

# We'll use the den year sample_id (rather than the forestry year sample id)
# as the default sample id
f_analysis$sample_id <- f_analysis$sample_id_den

# Subset to only columns we care about
# EDIT: this causes so many issues down the line with later wanting
# to examine a variable that didn't make the cut here. Maybe remove?
# f_analysis <- f_analysis |>
#   dplyr::select(sample_id, den_id, den_status, den_status_binary,
#                 sample_id_forest, sample_id_den,
#                 date_inspected_den, date_inspected_forest, year,
#                 region, latitude, longitude,
#                 struct_stage, age_class, canopy_closure,
#                 elevation_m, slope_pct, slope_aspect,
#                 bed_depth, bed_width, bed_length,
#                 hair_in_bed,
#                 forestry_treatment_desc,
#                 age_class, age_class_1:age_class_9,
#                 lt_3, gt_3, three_to_7, gt_8,
#                 f_prop_forest_60m,
#                 f_dist_lt40, f_dist_gt40,
#                 f_dist_from_edge, log_dist_from_edge,
#                 f_dist_road,
#                 windthrow_prct, windthrow_code,
#                 age_class_1:road_density_m2)
```

```{r f_full prep, include = FALSE}
f_full <- merge(dens, f, by = "den_id")
```

There are currently **`r length(unique(f$den_id))`** dens being tracked, and a total of **`r nrow(f)`** field visits completed to date (**`r Sys.Date()`**).

```{r den map, out.width='100%', fig.height=6.5, eval=require('leaflet'), echo = FALSE}
dens %>%
  st_transform(4326) %>%
  leaflet() %>% 
  addTiles() %>%
  setView(lng = -127.8, lat = 51.5, zoom = 6) %>%
  addCircleMarkers(layerId = ~den_id,
                   radius = 4,
                   color = "#c852ef",
                   stroke = FALSE,
                   fillOpacity = 0.8,
                   popup = ~htmltools::htmlEscape(den_id)) %>%
  addTiles("Jawg.Terrain", 
           options = providerTileOptions(accessToken = jawg_token),
           group = "Terrain") %>%
  addProviderTiles("Esri.WorldImagery",
                   group = "Satellite") %>%
  addLayersControl(baseGroups = c("Terrain", "Satellite"),
                   position = "topright") %>%
  addMeasure(primaryLengthUnit = "meters")
  
  
```

.footnote[*Use the menus on the top-right to change the basemap or perform measurements.*]

---

# Overall summary

```{r n field visits per year, dev.args=list(bg="transparent")}
f |> 
  dplyr::mutate(year = lubridate::year(date_inspected)) |>
  ggplot(aes(x = year)) +
  geom_bar() +
  scale_x_continuous(breaks = 2014:2025) +
  labs(x = "Year",
       y = "N field visits",
       title = "Number of field visits per year") +
  theme_minimal() 
```

---

# Overall summary

```{r n cameras per year, dev.args=list(bg="transparent")}
f |> 
  dplyr::mutate(year = lubridate::year(date_inspected)) |>
  dplyr::filter(grepl("Yes", monitored_by_camera)) |>
  ggplot(aes(x = year)) +
  geom_bar() +
  scale_x_continuous(limits = c(2014,2025.5), 
                     breaks = 2014:2025) +
  labs(x = "Year",
       y = "N deployed cameras",
       title = "Number of deployed cameras per year") +
  theme_minimal() 
```


---

# Overall summary

### Den Status - what have we got?

```{r n den status, echo=FALSE}
knitr::kable(table(f$den_status), col.names = c("Den Status", "N"))
```

---

# Overall summary

```{r n active dens per year, dev.args=list(bg="transparent")}
f |> 
  dplyr::filter(den_status %in% c("Currently active", "Active in last denning season")) |>
  dplyr::mutate(year = lubridate::year(date_inspected)) |>
  ggplot(aes(x = year)) +
  geom_bar() +
  scale_x_continuous(breaks = 2014:2024) +
  labs(x = "Year",
       y = "N active dens",
       title = "Number of dens determined to be 'Active' per year") +
  theme_minimal() 
```

---

# Where are our dens?
### District

```{r n districts tbl, echo = FALSE}
knitr::kable(table(dens$district), col.names = c("District", "N"))
```

---

# Where are our dens?
### Region

```{r n regions, fig.height = 5.5, dev.args=list(bg="transparent")}
dens |> 
  ggplot(aes(x = region)) +
  geom_bar() +
  labs(x = "Region",
       y = "N dens",
       title = "Number of dens in each region") +
  theme_minimal() 
```

---

# Where are our dens?
### District

```{r n districts fig, fig.height = 5.5, dev.args=list(bg="transparent")}
dens |> 
  ggplot(aes(x = district)) +
  geom_bar() +
  labs(x = "District",
       y = "N dens",
       title = "Number of dens in each district") +
  theme_minimal() 
```

---
class: center, middle, inverse

# What does a den look like?

---

# What does a den look like?
### Den Tree Species

```{r n den tree spp, echo = FALSE}
knitr::kable(table(dens$den_tree_species), col.names = c("Den Tree Species", "N"))
```

---

# What does a den look like?
### Proportion by tree species

```{r prct tree spp, echo = FALSE}
trees <- table(dens$den_tree_species)
knitr::kable(round((trees/sum(trees))*100, 0), col.names = c("Den Tree Species", "%"))
```

---

# What does a den look like?
### Den Type

```{r n den type, echo = FALSE}
knitr::kable(table(dens$den_type), col.names = c("Den Type", "N"))
```

---

# What does a den look like?
### DBH

```{r histogram DBH, fig.height = 5.5}
hist(dens$den_tree_dbh, main = "Histogram of Den Tree DBH", xlab = "DBH (cm)")
```

---

# What does a den look like?
### Chamber width, height, and length

```{r den measurements, fig.height = 5.5, dev.args=list(bg="transparent")}
dens |>
  sf::st_drop_geometry() |>
  dplyr::select(chamber_width, chamber_height, chamber_length) |>
  tidyr::pivot_longer(cols = 1:3,
                      names_to = "Measurement",
                      values_to = "cm") |>
  ggplot(aes(x = cm)) +
  geom_density(aes(color = Measurement,
                   fill = Measurement),
               alpha = 0.1) +
  scale_color_manual(values = c("#E69F00", "#009E73", "#CC79A7"),
                     name = "Measurement",
                     labels = c("Chamber height",
                                "Chamber length",
                                "Chamber width")) +
  scale_fill_manual(values = c("#E69F00", "#009E73", "#CC79A7"),
                    name = "Measurement",
                    labels = c("Chamber height",
                               "Chamber length",
                               "Chamber width")) +
  labs(x = "Measurement (cm)",
       y = "Density") +
  theme_minimal()
```

---

# What does a den look like?
### Dens with Bed Cups during each field visit (N)

```{r n bed cups tbl}
knitr::kable(table(f$bedding_cup_present), col.names = c("Bedding Cup Present?", "N"))
```

---

# What does a den look like?
### Dens with Bed Cups during each field visit (%)

```{r prct bed cups tbl}
cups <- table(f$bedding_cup_present)
knitr::kable(round(cups/sum(cups)*100, 0), col.names = c("Bedding Cup Present?", "%"))
```

---

# What does a den look like?
### What proporion of dens have certain bedding materials?

```{r bedding materials tbl}
bedding <- f[,c("den_id", "bedding_material_details")]
bedding$salal_yn <- grepl("salal", bedding$bedding_material_details, ignore.case = TRUE)
bedding$fern_yn <- grepl("fern", bedding$bedding_material_details, ignore.case = TRUE)
bedding$moss_yn <- grepl("moss", bedding$bedding_material_details, ignore.case = TRUE)
bedding$cedarhemlock_yn <- grepl("cedar|hemlock", bedding$bedding_material_details, ignore.case = TRUE)
bedding$needles_yn <- grepl("needles", bedding$bedding_material_details, ignore.case = TRUE)
bedding$twigsbranches_yn <- grepl("twig|twigs|branch|branches", bedding$bedding_material_details, ignore.case = TRUE)
bedding$duff_yn <- grepl("duff", bedding$bedding_material_details, ignore.case = TRUE)
bedding$scrapings_yn <- grepl("scraping|scrapings", bedding$bedding_material_details, ignore.case = TRUE)
bedding$nomaterial_yn <- grepl("(?<=No|no)(.*)(?=material)", bedding$bedding_material_details, ignore.case = TRUE, perl = TRUE)

bedding2 <- bedding |> 
    dplyr::select(-bedding_material_details) |> 
    dplyr:: group_by(den_id) |> 
    summarise_all(sum) |> 
    dplyr::select(-den_id)

bedding2[bedding2 != 0] <- 1

bedding2 <- data.frame(material = c("Salal", "Ferns", "Moss", "Cedar/Hemlock",
                                    "Needles", "Twigs/Branches", "Duff", "Scrapings", 
                                    "No imported material"),
                       n_dens = colSums(bedding2))
rownames(bedding2) <- NULL
bedding2$prct <- paste0(round(bedding2$n_dens / length(unique(bedding$den_id)), 2) * 100, "%")

knitr::kable(bedding2, col.names = c("Material", "N dens", "% dens"))
```

---

# What does a den look like?
### Hair in Den during each field visit (N)

```{r n hair in bed tbl}
knitr::kable(table(f$hair_in_bed), col.names = c("Hair in Den?", "N"))
```

---

# What does a den look like?
### Hair in Den during each field visit (%)

```{r prct hair in bed tbl}
hair <- table(f$hair_in_bed)
knitr::kable(round(hair/sum(hair)*100, 0), col.names = c("Hair in Den?", "%"))
```

---

# What does a den look like?
### Hair on Entrance during each field visit (N)

```{r n hair on entrance tbl}
knitr::kable(table(f$hair_on_entrance), col.names = c("Hair on Entrance?", "N"))
```

---

# What does a den look like?
### Hair on Entrance during each field visit (%)

```{r prct hair on entrance tbl}
hair <- table(f$hair_on_entrance)
knitr::kable(round(hair/sum(hair)*100, 0), col.names = c("Hair on Entrance?", "%"))
```

---

# What does a den look like?
### Age Class

```{r n age class tbl, echo = FALSE}
knitr::kable(table(dens$age_class), col.names = c("Age Class", "N"))
```

---

# What does a den look like?
### Den State (initial visit)

```{r n den state tbl, echo = FALSE}
knitr::kable(table(dens$den_state), col.names = c("Den State", "N"))
```

---

# What's the geography like?
### Elevation

```{r histogram elevation}
hist(dens$elevation_m, main = "Histogram of den elevations", xlab = "Elevation (m)")
```

--- 

# What's the geography like?
### Slope grade (%)

```{r histogram slope}
hist(dens$slope_pct, main = "Histogram of slope grades", xlab = "Slope (%)")
```

--- 

# What's the geography like?
### Slope aspect

```{r histogram aspect}
hist(dens$slope_aspect, main = "Histogram of slope aspects", xlab = "Slope aspect (degrees)",
     xlim = range(0, 360), breaks = seq(0, 360, 45))
```

---
class: center, middle, inverse

# Den Status

## Rates of Re-Use

---

### Den Status - what have we got?

```{r n den status tbl 2, echo=FALSE}
knitr::kable(table(f$den_status), col.names = c("Den Status", "N"))
```

---
class: center

### "Active"

Dens with the highlighted status were considered "confirmed active" within the last season.

```{r, echo = FALSE, results = 'asis'}
if (den_status_strict == FALSE) {
  cat('.footnote[\\* If the first datapoint in the timeseries was `Active recently (0-4 seasons)`, we counted it as `Active` (*N* =', nrow(f[f$den_status == "Active recently (0-4 seasons)" & f$den_status_binary == "Active", ]),').]')
}
```

```{r highlight active tbl, echo=FALSE}
if (den_status_strict) {
  f |>
    dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                      "Active recently (0-4 seasons)",
                                      den_status)) |>
    dplyr::pull(den_status) |>
    table() |>
    knitr::kable(col.names = c("Den Status", "N")) |> 
    kableExtra::kable_styling() |> 
    kableExtra::row_spec(c(1), bold = TRUE, background = "#b58900") |>
    kableExtra::kable_styling(font_size = 14)
} else {
  f |>
    dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                      "Active recently (0-4 seasons)*",
                                      den_status)) |>
    dplyr::pull(den_status) |>
    table() |>
    knitr::kable(col.names = c("Den Status", "N")) |> 
    kableExtra::kable_styling() |> 
    kableExtra::row_spec(c(1), bold = TRUE, background = "#b58900") |>
    kableExtra::row_spec(c(2), bold = TRUE, background = "#e1c056") |>
    kableExtra::kable_styling(font_size = 14)
}
```

---
class: center

### "Non-Active"

Dens with the highlighted status were considered "confirmed *not* active" within the last season.

```{r, echo = FALSE, results = 'asis'}
if (den_status_strict == FALSE) {
  cat('.footnote[\\* If the first datapoint in the timeseries was `Active recently (0-4 seasons)`, we counted it as `Active` (*N* =', nrow(f[f$den_status == "Active recently (0-4 seasons)" & f$den_status_binary == "Active", ]),').]')
}
```

```{r highlight non-active tbl, echo=FALSE}
if (den_status_strict) {
  f |>
    dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                      "Active recently (0-4 seasons)",
                                      den_status)) |>
    dplyr::pull(den_status) |>
    table() |>
    knitr::kable(col.names = c("Den Status", "N")) |> 
    kableExtra::kable_styling() |> 
    #kableExtra::row_spec(c(1:4), bold = FALSE, background = "#b58900") |>
    kableExtra::row_spec(c(3:6), bold = TRUE, background = "#93a1a1") |>
    kableExtra::kable_styling(font_size = 14)
} else {
 f |>
  dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                    "Active recently (0-4 seasons)*",
                                    den_status)) |>
  dplyr::pull(den_status) |>
  table() |>
  knitr::kable(col.names = c("Den Status", "N")) |> 
  kableExtra::kable_styling() |> 
  #kableExtra::row_spec(c(1:4), bold = FALSE, background = "#b58900") |>
  kableExtra::row_spec(c(3:6), bold = TRUE, background = "#93a1a1") |>
  kableExtra::kable_styling(font_size = 14) 
}
```

---
class: center

### "Unknown/Obsolete"

Dens with the highlighted status were excluded from den status assessments.


```{r, echo = FALSE, results = 'asis'}
if (den_status_strict == FALSE) {
  cat('.footnote[\\* If the first datapoint in the timeseries was `Active recently (0-4 seasons)`, we counted it as `Active` (*N* =', nrow(f[f$den_status == "Active recently (0-4 seasons)" & f$den_status_binary == "Active", ]),').]')
}
```

```{r highlight unknown obsolete tbl, echo=FALSE}
if (den_status_strict) {
  f |>
    dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                      "Active recently (0-4 seasons)",
                                      den_status)) |>
    dplyr::pull(den_status) |>
    table() |>
    knitr::kable(col.names = c("Den Status", "N")) |> 
    kableExtra::kable_styling() |> 
    #kableExtra::row_spec(c(1:4), bold = FALSE, background = "#b58900") |>
    #kableExtra::row_spec(c(5:14), bold = FALSE, background = "#93a1a1") |>
    #kableExtra::row_spec(c(2), bold = TRUE, background = "#e1c056") |>
    kableExtra::row_spec(c(2, 7:8), bold = TRUE, color = "white", background = "#cb4b16") |>
    kableExtra::kable_styling(font_size = 14) 
} else {
 f |>
  dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                    "Active recently (0-4 seasons)*",
                                    den_status)) |>
  dplyr::pull(den_status) |>
  table() |>
  knitr::kable(col.names = c("Den Status", "N")) |> 
  kableExtra::kable_styling() |> 
  #kableExtra::row_spec(c(1:4), bold = FALSE, background = "#b58900") |>
  #kableExtra::row_spec(c(5:14), bold = FALSE, background = "#93a1a1") |>
  kableExtra::row_spec(c(2), bold = TRUE, background = "#e1c056") |>
  kableExtra::row_spec(c(7:8), bold = TRUE, color = "white", background = "#cb4b16") |>
  kableExtra::kable_styling(font_size = 14) 
}
```

---
class: center

### All statuses

Dens with the highlighted status were excluded from den status assessments.

```{r, echo = FALSE, results = 'asis'}
if (den_status_strict == FALSE) {
  cat('.footnote[\\* If the first datapoint in the timeseries was `Active recently (0-4 seasons)`, we counted it as `Active` (*N* =', nrow(f[f$den_status == "Active recently (0-4 seasons)" & f$den_status_binary == "Active", ]),').]')
}
```

```{r highlight all statuses tbl, echo=FALSE}
if (den_status_strict) {
  f |>
    dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                      "Active recently (0-4 seasons)",
                                      den_status)) |>
    dplyr::pull(den_status) |>
    table() |>
    knitr::kable(col.names = c("Den Status", "N")) |> 
    kableExtra::kable_styling() |> 
    kableExtra::row_spec(c(1), bold = FALSE, background = "#b58900") |>
    kableExtra::row_spec(c(3:6), bold = FALSE, background = "#93a1a1") |>
    kableExtra::row_spec(c(2, 7:8), bold = TRUE, color = "white", background = "#cb4b16") |>
    kableExtra::kable_styling(font_size = 14)
} else {
 f |>
  dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                    "Active recently (0-4 seasons)*",
                                    den_status)) |>
  dplyr::pull(den_status) |>
  table() |>
  knitr::kable(col.names = c("Den Status", "N")) |> 
  kableExtra::kable_styling() |> 
  kableExtra::row_spec(c(1), bold = FALSE, background = "#b58900") |>
  kableExtra::row_spec(c(2), bold = TRUE, background = "#e1c056") |>
  kableExtra::row_spec(c(3:6), bold = FALSE, background = "#93a1a1") |>
  kableExtra::row_spec(c(7:8), bold = TRUE, color = "white", background = "#cb4b16") |>
  kableExtra::kable_styling(font_size = 14) 
}
```

---

# Rates of re-use

First need to categorize dens into `Active`, `Not Active`, or `Unknown`.
Based on the highlighted rows in the tables of the previous slides, we have:

```{r den_status_binary tbl, echo = FALSE}
# # Add a `den_status_binary` column
# f <- f |> dplyr::mutate(den_status_binary = dplyr::case_when(grepl("No", den_status) ~ "Not Active",
#                                                      den_status %in% c("Active in last denning season", "Currently active") ~ "Active",
#                                                      den_status == "Obsolete" ~ "Obsolete",
#                                                      den_status == "Unknown" ~ "Unknown",
#                                                      TRUE ~ "Unknown"))

# Double check our categories
unique(f[,c("den_status", "den_status_binary")]) |> 
  dplyr::arrange(den_status_binary) |>
  knitr::kable()
```


---

# Rates of re-use

First need to categorize dens into `Active`, `Not Active`, or `Unknown`.
Based on the highlighted rows in the tables of the previous slides, we have:

```{r n den status binary tbl}
plyr::count(f$den_status_binary) |>
  knitr::kable(col.names = c("Den Status", "N"))
```

Total number of visits = **`r nrow(f)`**

---

# Rates of re-use

First need to categorize dens into `Active`, `Not Active`, or `Unknown`.
Based on the highlighted rows in the tables of the previous slides, we have:

```{r prct den status binary tbl}
plyr::count(f$den_status_binary) |>
  dplyr::mutate(freq = round(freq/nrow(f) * 100)) |>
  knitr::kable(col.names = c("Den Status", "%"))
```

Total number of visits = **`r nrow(f)`**

---

# Rates of re-use

For now, I'm counting `Unknown`s the same as `Not Active`.

This is a quick and dirty assignment of 're-use' - it doesn't take into account if there's been a large temporal gap (e.g., years) between visits.

But, essentially, if the status was `Active` for two records in a row, it's counted as *re-used*.

```{r re-use data prep}
# Arrange table by den_id and date_inspected
f <- f[order(f$den_id, f$date_inspected),]
# Add in a cumulative visit col by each den - i.e. the Nth field visit to the given den
f <- f |>
  dplyr::group_by(den_id) |>    
  dplyr::mutate(cumulative_visit = cumsum(!is.na(den_id)))
# Create `reuse_yn` col - if den was revisited at all
f <- f |> 
    dplyr::group_by(den_id) |>
    dplyr::mutate(count_active = sum(den_status_binary == "Active"),
                  reuse_yn = count_active > 1)
# Create `consecutiveuse_yn` col - if den visited two years in a row
f <- f |> 
  dplyr::group_by(den_id) |>
  dplyr::mutate(year_diff = lubridate::year(date_inspected) - dplyr::lag(lubridate::year(date_inspected))) |> # so cumulative visits only count if they're one year apart (e.g., a visit in 2016 and then in 2020 is NOT a cumulative visit)
  dplyr::mutate(consecutiveuse_yn = ifelse((cumulative_visit == 1 & year_diff == 1),
                                  # If it's the first visit to the den, set `reuse_yn` == NA
                                  NA, 
                                  # Else if it's NOT the first visit, and the previous record says "Active", set `reuse_yn` == TRUE
                                  (dplyr::lag(den_status_binary) == "Active" & den_status_binary == "Active"))
                )
```

---

#### Rates of re-use

```{r rates of reuse tbl, echo = FALSE}
f[,c("den_id", "sample_id", "date_inspected", "cumulative_visit", "den_status_binary", "reuse_yn", "consecutiveuse_yn")] |> 
  DT::datatable(options = list(
    pageLength = 8,
    scrollX = FALSE,
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '50%'});",
      "}"
      )
    )) |>
  DT::formatStyle(columns = c(1:6), fontSize = "50%") |>
  DT::formatStyle(columns = c(1:6), width = c("5%"))
```

---

# Rates of re-use

#### Number of dens never used

```{r n dens number times active}
f |> 
  dplyr::group_by(den_id) |>
  dplyr::summarise(count_active = mean(count_active)) |>
  dplyr::group_by(count_active) |>
  dplyr::summarise(n = dplyr::n()) |>
  knitr::kable(col.names = c("Number of times den was Active", "N dens"))
```

---

# Rates of re-use

#### Number of dens never used

```{r prct dens number times active}
f |> 
  dplyr::group_by(den_id) |>
  dplyr::summarise(count_active = mean(count_active)) |>
  dplyr::group_by(count_active) |>
  dplyr::summarise(n = dplyr::n()) |>
  dplyr::mutate(prct = round(n/sum(n) * 100)) |>
  dplyr::select(count_active, prct) |>
  knitr::kable(col.names = c("Number of times den was Active", "%"))
```


---

# Rates of re-use

#### Number of consecutive re-uses

Den was re-used two years in a row

.footnote[*Note that `NA` signifies the first visit to a den - we don't know if `reuse_yn == TRUE` or `FALSE` bc it's the first visit*]

```{r n consecutive reuse tbl}
knitr::kable(plyr::count(f$consecutiveuse_yn), col.names = c("Re-Used Consecutively (T/F)", "N"))
```

---

# Rates of re-use

#### Percent of consecutive use

Den was re-used two years in a row

.footnote[*Note that `NA` signifies the first visit to a den - we don't know if `reuse_yn == TRUE` or `FALSE` bc it's the first visit*]

```{r prct consecutive reuse tbl}
knitr::kable(plyr::count(f$consecutiveuse_yn) |> dplyr::mutate(freq = round(freq/nrow(f) * 100)), col.names = c("Re-Used Consecutively (T/F)", "%"))
```


---

# Rates of re-use

### A few example dens...

---

# Rates of re-use

### ADA_EveRiver_1

Was never active in the first place.

```{r ADA_EveRiver_1 reuse, echo = FALSE}
f[f$den_id == "ADA_EveRiver_1", c("den_id", "sample_id", "date_inspected", "cumulative_visit", "den_status_binary", "reuse_yn")] |>
  knitr::kable() |>
  kableExtra::kable_styling(font_size = 14)
```

---

# Rates of re-use

### COU_CousCreek_2

Active more than once, but not two years in a row. 

```{r COU_CousCreek_2 reuse, echo = FALSE}
f[f$den_id == "COU_CousCreek_2", c("den_id", "sample_id", "date_inspected", "cumulative_visit", "den_status_binary", "reuse_yn")] |>
  knitr::kable() |>
  kableExtra::kable_styling(font_size = 14)
```

---

# Rates of re-use

### TSI_MountRussell_2

Was active, but then turned `Obsolete`.

```{r TSI_MountRussell_2 reuse, echo = FALSE}
f[f$den_id == "TSI_MountRussell_2", c("den_id", "sample_id", "date_inspected", "cumulative_visit", "den_status_binary", "reuse_yn")] |>
  knitr::kable() |>
  kableExtra::kable_styling(font_size = 14)
```

---

# Rates of re-use

### SAN_RonningCreek_2

Active for two years in a row!

```{r SAN_RonningCreek_2 reuse, echo = FALSE}
f[f$den_id == "SAN_RonningCreek_2", c("den_id", "sample_id", "date_inspected", "cumulative_visit", "den_status_binary", "reuse_yn")] |>
  knitr::kable() |>
  kableExtra::kable_styling(font_size = 14)
```


---
class: center, middle, inverse

# Forestry summary data

---

### Canopy closure

Note this value was not updated past the first field visit.

```{r histogram canopy closure}
hist(dens$canopy_closure, main = "Histogram of canopy closure", xlab = "Canopy closure (%)", xlim = range(0, 100))
```

---

### Patch Type

.footnote[Note that not all dens have patch size categorized (N = `r nrow(f[!is.na(f$forestry_treatment_desc), ])` out of `r nrow(f)`).]

```{r patch type count, fig.height = 5.5}
ggplot(f[!is.na(f$forestry_treatment_desc),]) + 
  geom_bar(aes(x = forestry_treatment_desc,
               fill = forestry_treatment_desc)) +
  scale_fill_bright(name = "Patch Type") +
  scale_x_discrete(labels = c("CF", "Edge", "LRP", "MRP", "NR;NS", "NR;SI", "Other", "NA")) +
  labs(x = "Patch Type",
       y = "Count") +
  theme_minimal() #+ 
  #theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))
```

---

### Proportion forested within 60m

Note this includes all field visits, including dens with repeated visits.

```{r summary f prop forest}
summary(f$f_prop_forest_60m)
```

```{r histogram prct forested, fig.height=5}
hist(f$f_prop_forest_60m, main = "Histogram of Proportion Forested", xlab = "Proportion Forested within 60m (%)")
```

---

### Distance to <40 yo forest

Note this includes all field visits, including dens with repeated visits.

```{r summary dist_lt40}
summary(f$f_dist_lt40)
```

```{r histogram dist_lt40, fig.height=5}
hist(f$f_dist_lt40, main = "Histogram of Distance to <40yo Forest", xlab = "Distance to <40 yo forest (m)")
```

---

### Distance to <40 yo forest: Zoomed in to 0-500m

Majority of dens are <100 meters from <40 yo forest (cutblock edge).

```{r}
summary(f$f_dist_lt40)
```

```{r histgram dist_lt40 zoomed, fig.height=5}
hist(f$f_dist_lt40, main = "Histogram of Distance to <40yo Forest", xlab = "Distance to <40 yo forest (m)", xlim = range(0, 500), breaks = 100)
```

---

### Distance to >40 yo forest

Note this includes all field visits, including dens with repeated visits.

```{r summary dist_gt40}
summary(f$f_dist_gt40)
```

```{r histogram dist_gt40, fig.height=5}
hist(f$f_dist_gt40, main = "Histogram of Distance to >40yo Forest", xlab = "Distance to >40 yo forest (m)")
```

---

### Distance to >40 yo forest: Zoomed in to 0-50m

Vast majority of dens are already *within* >40 yo forest.

```{r}
summary(f$f_dist_gt40)
```

```{r histgram dist_gt40 zoomed, fig.height=5}
hist(f$f_dist_gt40, main = "Histogram of Distance to >40yo Forest", xlab = "Distance to >40 yo forest (m)", xlim = c(0, 50), breaks = 100)
```


---

### Distance to nearest road

Note this includes all field visits, including dens with repeated visits.

```{r summary dist road}
summary(f$f_dist_road)
```

```{r histogram dist_road, fig.height=5}
hist(f$f_dist_road, main = "Histogram of Distance to Nearest Road", xlab = "Distance to nearest road (m)")
```

---

### Distance to nearest road: Zoomed in to 0-500m

Distribution is skewed towards 0, but less so than distance to cutblock edge/mature growth.

```{r}
summary(f$f_dist_road)
```

```{r histogram dist_road zoomed, fig.height=5}
hist(f$f_dist_road, main = "Histogram of Distance to Nearest Road", xlab = "Distance to nearest road (m)", xlim = c(0, 500), breaks = 100)
```


---

### Proportion age class within 1.5 km

Note this includes all field visits, including dens with repeated visits

```{r prct age class 1.5km}
# The age class cols are already percentages for each year. So, just
# take the mean percentage of each age class across all years
round(colSums(prop_1km[,3:11]) / nrow(prop_1km)) |>
  knitr::kable(col.names = c("Stand Age Class", "Percentage"))
```

---

### Proportion age class within 1.5 km

Note this includes all field visits, including dens with repeated visits

```{r prct age class 1.5km fig, echo = FALSE, fig.width = 10, dev.args=list(bg="transparent")}
prop_1km |>  
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 3:11, names_to = "age_class", names_prefix = "age_class_") |>
  dplyr::mutate(age_class = factor(age_class, levels = c(1:9))) |>
  # Then summarize the mean % age class by year 
  dplyr::group_by(year, age_class) |> 
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  scale_fill_light(reverse = TRUE) +
  labs(y = "%") +
  theme_minimal()
```

---

### Proportion age class within 1.5 km

Note this includes all field visits, including dens with repeated visits

```{r prct lt3 gt3 age class 1.5km, echo = FALSE, fig.width = 10, dev.args=list(bg="transparent")}
prop_1km |>  
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 3:11, names_to = "age_class", names_prefix = "age_class_") |>
  # Condense age class for each den visit into either ">= 3" or "< 3"
  dplyr::mutate(age_class = ifelse(grepl("1|2", age_class), "Less than 3", "Greater or equal to 3")) |>
  dplyr::mutate(age_class = factor(age_class, levels = c("Less than 3", "Greater or equal to 3"))) |> # Flip plotting order so it stays lined up with previous graph
  dplyr::group_by(den_id, year, age_class) |>
  dplyr::summarise(value = sum(value)) |>
  # Then summarize the mean % age class by year
  dplyr::group_by(year, age_class) |>
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  scale_fill_light(reverse = TRUE) +
  labs(y = "%") +
  theme_minimal()
```

---

### Proportion age class within 1.5 km

Note this includes all field visits, including dens with repeated visits

```{r prct lt3 3-7 gt7 age class 1.5km, echo = FALSE, fig.width = 10, dev.args=list(bg="transparent")}
prop_1km |>  
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 3:11, names_to = "age_class", names_prefix = "age_class_") |>
  dplyr::mutate(age_class = as.numeric(age_class)) |>
  # Condense age class for each den visit into either ">= 3" or "< 3"
  dplyr::mutate(age_class = dplyr::case_when(age_class < 3 ~ "Less than 3",
                                             age_class >= 8 ~ "Older than 7",
                                             TRUE ~ "3 to 7")) |>
  dplyr::mutate(age_class = factor(age_class, levels = c("Less than 3", "3 to 7", "Older than 7"))) |>
  dplyr::group_by(den_id, year, age_class) |>
  dplyr::summarise(value = sum(value)) |>
  # Then summarize the mean % age class by year
  dplyr::group_by(year, age_class) |>
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  scale_fill_light(reverse = TRUE) +
  labs(y = "%") +
  theme_minimal()
```

---

### Road density within 1.5 km

Note this includes all field visits, including dens with repeated visits.

```{r summary road density}
summary(road_density$road_density_m2)
```

```{r histogram road_density_m2, fig.height=5}
hist(road_density$road_density_m2, main = "Histogram of Road Density", xlab = "Road Density within 1.5km radius")
```

---

### Road density within 1.5 km

It doesn't change much through time... (this will be a theme)

```{r road density through time, echo = FALSE, fig.width = 7, dev.args=list(bg="transparent")}
road_density |>
  ggplot(aes(x = year, y = road_density_m2, color = den_id)) +
  geom_line() +
  geom_point() +
  labs(title = "Road density for each den through time") +
  theme_minimal() +
  theme(legend.position = "none")
```

---
class: center, middle, inverse

# Forestry vs. Den Status

---

# Forestry vs. Den Status

Now, we need to do a bit of data wrangling. In theory, the den status of **the current year** is influenced by the forestry data **from the year before**. So, we match the den status with last year's forestry data from our field visits. In doing so, this cuts our dataset own to `r nrow(f_analysis)` records. 

With the exception of age class and canopy closure, all subsequent plots show den status of year *N* versus forestry data from year *N - 1*. Age class and canopy closure were only measured once in the study (at the first den visit).

---

## Den Status vs Age Class

```{r chisq den status v age class}
chisq <- f_full |>
  sf::st_drop_geometry() |>
  dplyr::mutate(den_status_binary = dplyr::case_when(grepl("No", den_status) ~ "Not Active",
                                                     den_status %in% c("Active in last denning season", "Currently active") ~ "Active",
                                                     den_status == "Obsolete" ~ "Obsolete",
                                                     den_status == "Unknown" ~ "Unknown",
                                                     TRUE ~ "Unknown")) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::group_by(age_class, den_status_binary) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = age_class,
                     values_from = n) |>
  dplyr::mutate(den_status_binary = dplyr::if_else(!is.na(den_status_binary), den_status_binary, "NA")) |>
  tibble::column_to_rownames(var = "den_status_binary") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

## Den Status vs Canopy Closure

```{r den status v canopy closure, fig.height = 5.5, echo = FALSE, dev.args=list(bg="transparent")}
#hrbrthemes::import_plex_sans()

ggplot(f_full, aes(x = den_status_binary,
                       y = canopy_closure,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) + 
  labs(x = "Den Status",
       y = "Canopy Closure (%)")
```

---

## Den Status vs Patch Type

```{r den status v patch type}
chisq <- f_analysis |>
  sf::st_drop_geometry() |>
  dplyr::filter(!is.na(forestry_treatment_desc)) |>
  dplyr::group_by(forestry_treatment_desc, den_status_binary) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = den_status_binary,
                     values_from = n) |>
  tibble::column_to_rownames(var = "forestry_treatment_desc") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

## Den Status vs Proportion Forested within 60m

```{r den status v prop forest, fig.height = 5.5, echo = FALSE, dev.args=list(bg="transparent")}
#hrbrthemes::import_plex_sans()

ggplot(f_analysis, aes(x = den_status_binary,
                       y = f_prop_forest_60m,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) + 
  labs(x = "Den Status",
       y = "Proportion Forested within 60m (%)")
```


---

## Den Status vs Distance to <40 yo Forest

```{r den status v dist_lt40, echo = FALSE, dev.args=list(bg="transparent")}
ggplot(f_analysis, aes(x = den_status_binary, 
                       y = f_dist_lt40,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  scale_y_log10() +
  annotation_logticks(side = "l") +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "LOG Distance to <40 yo forest (m)")
```


---

## Den Status vs Distance to >40 yo Forest

```{r den status v dist_gt40, echo = FALSE, dev.args=list(bg="transparent")}
ggplot(f_analysis, aes(x = den_status_binary, 
                       y = f_dist_gt40, 
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  scale_y_log10() +
  annotation_logticks(side = "l") +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "LOG Distance to >40 yo forest (m)")
```

---

## Den Status vs Distance to >40 yo Forest

What are those 6 data points where distance to mature forest is >30 meters? 

Turns out it's all from 3 distinct dens:

```{r}
y <- f_analysis[which(f_analysis$f_dist_gt40 > 30 & f_analysis$den_status_binary == "Active"),]

y[,c("den_id", "sample_id", "landscape_unit", "x_den_data_source", "struct_stage", "age_class", "canopy_closure", "den_type", "den_tree_species", "den_tree_dbh", "tree_appearance_code", "forestry_treatment_desc", "f_prop_forest_60m", "f_dist_lt40", "f_dist_gt40", "f_dist_road", "windthrow_code", "lt_3", "three_to_7", "gt_8", "road_density_m2")] |> 
  DT::datatable(options = list(
    pageLength = 8,
    scrollX = TRUE,
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '50%'});",
      "}"
      )
    )) |>
  DT::formatStyle(columns = c(1:6), fontSize = "50%") |>
  DT::formatStyle(columns = c(1:6), width = c("5%"))
```

---

## Den Status vs Distance to Nearest Road

```{r den status v dist_road, echo = FALSE, dev.args=list(bg="transparent")}
ggplot(f_analysis, aes(x = den_status_binary, 
                       y = f_dist_road,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  scale_y_log10() +
  annotation_logticks(side = "l") +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "LOG Distance to nearest road")
```

---

## Den Status vs Proportion Old Growth

'Old growth' being % coverage of age class 8 or 9 within 1.5km of the den.

```{r den status v gt_8, echo = FALSE, dev.args=list(bg="transparent")}
ggplot(f_analysis, aes(x = den_status_binary, 
                       y = gt_8,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "Old Growth within 1.5km (%)")
```

---

## Den Status vs Proportion New Growth

'New growth' being % coverage of age class 1 or 2 within 1.5km of the den.

```{r den status v lt_3, echo = FALSE, dev.args=list(bg="transparent")}
ggplot(f_analysis, aes(x = den_status_binary, 
                       y = lt_3,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  scale_y_continuous(limits = c(0,100)) +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "New Growth within 1.5km (%)")
```


---
class: center, middle, inverse

# How well are we sampling the landscape?

---

# How well are we sampling the landscape?

The next set of slides will compare points randomly sampled across the landscape versus our dens. Compared to just randomly dropping pins on a map of Vancouver Island and Haida Gwaii, how well are we sampling the landscape with our sample of dens?

```{r pseudo dens setup, include = FALSE}
# pseudo_dens = randomly sampled points on the landscape
# to compare to our actual sampled dens
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(pseudo_dens))

# First, for the pseudo den data, we're going to make
# the same assumption as for the real data - this year's
# den status needs to be paired with last year's forestry.
# Add 1 from the pseudo data `year` so that the 
# data runs from 2019-2023, rather than 2020-2024, 
# because then it will line up with our real data (which
# only runs until 2023.)
pseudo_dens$year <- pseudo_dens$year + 1

# Add latitude, longitude cols to data
pseudo_dens <- cbind(pseudo_dens, st_coordinates(pseudo_dens))
names(pseudo_dens)[grep("X", names(pseudo_dens))] <- "longitude"
names(pseudo_dens)[grep("Y", names(pseudo_dens))] <- "latitude"

# Assign either VI or HG to data, to examine by island
pseudo_dens$region <- ifelse(pseudo_dens$latitude > 800000, "HG", "VI")

##### Assign random den status #####

# Randomly assign a den_status to the pseudo_data, following
# similar proportions as the actual data

# Pull the % distribution of den statuses from the actual
# data, then round to the nearest hundreth. We'll use those
# percentages to simulate den status in the pseudo data.
status_freq <- round(prop.table(table(f_analysis$den_status)), 2)
status_freq

# Generate random den status for our pseudo dens
pseudo_dens$den_status <- sample(names(status_freq), 
                                 nrow(pseudo_dens), 
                                 replace = TRUE, 
                                 prob = status_freq)

# Check that frequencies line up
prop.table(table(pseudo_dens$den_status))

# Make den status a factor
pseudo_dens$den_status <- factor(x = pseudo_dens$den_status,
                                 levels = c("Currently active", #x
                                            "Active in last denning season", #x
                                            "Active recently (0-4 seasons)", #x
                                            "Not active in last season, but recent use (1-4 seasons)", #x
                                            "Not active in last season, no recent use (>4 seasons)", #x
                                            "No recent evidence of use (>4 seasons)", #x
                                            "Not active in last season", #x
                                            "Obsolete", #x
                                            "Unknown")) #x

# Bin into binary categories
pseudo_dens <- pseudo_dens |> 
    dplyr::mutate(den_status_binary = dplyr::case_when(grepl("^No", den_status) ~ "Not active",
                                                     den_status == "Obsolete" ~ "Obsolete",
                                                     den_status == "Unknown" ~ "Unknown",
                                                     TRUE ~ "Active"))

if (den_status_strict == FALSE) {
  # If "Active recently (0-4 seasons)" is the very first data point, 
  # change it to "Active". 
  pseudo_dens <- pseudo_dens |>
    dplyr::arrange(den_id, date_inspected) |>
    dplyr::group_by(den_id) |>
    dplyr::mutate(cumulative_visit = cumsum(!is.na(den_id))) |>
    dplyr::mutate(den_status_binary = ifelse(cumulative_visit == 1 & den_status == "Active recently (0-4 seasons)",
                                             "Active",
                                             den_status_binary)) 
}

# Pull our parks shapefiles
parks1 <- withr::with_dir(rprojroot::find_root('_targets.R'),
                          tar_read(hg_vi_tantalis_parks))
parks2 <- withr::with_dir(rprojroot::find_root('_targets.R'),
                          tar_read(hg_vi_tantalis_cons_areas))
parks3 <- withr::with_dir(rprojroot::find_root('_targets.R'),
                          tar_read(hg_vi_federal_parks))

names(parks2)[1] <- "PROTECTED_LANDS_NAME"
parks2$PROTECTED_LANDS_DESIGNATION <- "CONSERVANCY AREA"

names(parks3)[2] <- "PROTECTED_LANDS_NAME"
parks3$PROTECTED_LANDS_DESIGNATION <- "FEDERAL PARK"

parks <- dplyr::bind_rows(parks1, parks2, parks3)
parks <- st_as_sf(parks, wkt = "WKT_GEOM")
st_crs(parks) <- 3005
names(parks)[5] <- "geometry" # rename geometry column
st_geometry(parks) <- "geometry"
names(parks) <- tolower(names(parks))

rm(parks1, parks2, parks3)

# Intersect parks with dens/pseudo_dens, so we know how
# many pseudo dens were generated inside park lands
pseudo_dens$in_park <- FALSE
pseudo_dens[["in_park"]][unlist(st_intersects(parks, pseudo_dens))] <- TRUE

dens$in_park <- FALSE
dens[["in_park"]][unlist(st_intersects(parks, dens))] <- TRUE

# Merge dens$in_park to f_analysis
f_analysis <- merge(f_analysis, sf::st_drop_geometry(dens[,c("den_id", "in_park")]))

# And finally pull a shapefile of our study area
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(study_area))

##### Pull verification data #####
# Then pull our verification data
# Even though we've manually verified the den data to 
# be the best it can be, we're still going to compare
# just the autogenerated GIS forestry data for both
# groups, to ensure it's an apples-to-apples 
# comparison.
fv <- withr::with_dir(rprojroot::find_root('_targets.R'),
                            tar_read(forestry_verifications_full)) # read data verification results
pfv <- withr::with_dir(rprojroot::find_root('_targets.R'), 
                       tar_read(pseudo_forestry_verifications_full)) # pseudo data verification results

# Merge verification data to the spatial data
f_analysis <- merge(f_analysis, fv, by.x = "sample_id_den", by.y = "sample_id")
pseudo_dens <- merge(pseudo_dens, pfv, by = "sample_id")


##### Pull DEM data #####
# For each pseudo den, we have elevation, slope (%),
# and slope aspect, extracted from the BC CDED 30m data.
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(pseudo_dens_dem))
pseudo_dens_dem <- unique(pseudo_dens_dem)

pseudo_dens <- merge(pseudo_dens, pseudo_dens_dem)

rm(pseudo_dens_dem)

# And also clean the DEM data fields in the real data
f_analysis[["elevation_m"]][which(f_analysis$elevation_m == 999)] <- NA
f_analysis[["slope_pct"]][which(f_analysis$slope_pct > 200)] <- NA
f_analysis[["slope_aspect"]][which(f_analysis$slope_aspect > 360)] <- NA

##### Pull age class data #####
# For each pseudo den, we have the 2023 VRI age class.
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(pseudo_dens_age_class))
pseudo_dens_age_class <- sf::st_drop_geometry(pseudo_dens_age_class)

pseudo_dens <- merge(pseudo_dens, pseudo_dens_age_class, all.x = TRUE)

rm(pseudo_dens_age_class)

# And also clean up the age class field in the real data
# This will produce some NAs
pseudo_dens$proj_age_class_cd_1 <- as.numeric(pseudo_dens$proj_age_class_cd_1)
f_analysis$proj_age_class_cd_1 <- as.numeric(substring(f_analysis$age_class, 1, 1))



##### % age class #####
# already did this for f_analysis in one of the first chunks
pseudo_prct <- withr::with_dir(rprojroot::find_root('_targets.R'),
                            tar_read(pseudo_prct_age_class_1.5km))

# Bin the data into groups (sort of ~young, old, medium, very old)
pseudo_prct$lt_3 <- rowSums(pseudo_prct[,c("age_class_1", "age_class_2")])
pseudo_prct$gt_3 <- rowSums(pseudo_prct[,6:12])
pseudo_prct$three_to_7 <- rowSums(pseudo_prct[,6:10])
pseudo_prct$gt_8 <- rowSums(pseudo_prct[,c("age_class_8", "age_class_9")])

# Merge with den status - so we can look at percent of each
# age class with activity status
pseudo_dens <- merge(pseudo_dens, pseudo_prct, by = "sample_id")
pseudo_dens <- dplyr::select(pseudo_dens, -den_id.y, -year.y)
names(pseudo_dens)[grep("den_id.x", names(pseudo_dens))] <- "den_id"
names(pseudo_dens)[grep("year.x", names(pseudo_dens))] <- "year"


##### Road density #####
# `road_density` already loaded in the first chunk
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(pseudo_road_density))

pseudo_road_density <- pseudo_road_density[,c("sample_id", "road_density_m2")]

# Note the all.x = TRUE. If the den isn't in
# the road density df_analysis, the road density is 0.
pseudo_dens <- merge(pseudo_dens, pseudo_road_density, by = "sample_id", all.x = TRUE)
pseudo_dens$road_density_m2 <- ifelse(is.na(pseudo_dens$road_density_m2), 0, pseudo_dens$road_density_m2)

##### Merge datasets #####
pseudo_dens$type <- "Pseudo"
f_analysis$type <- "Real"

full <- dplyr::bind_rows(pseudo_dens, f_analysis)

# We'll use the den year sample_id (rather than the forestry year sample id)
# as the default sample id
full$sample_id <- ifelse(is.na(full$sample_id), full$sample_id_den, full$sample_id)

# Subset to only columns we care about + full observations
full <- full |> 
  dplyr::select(sample_id, den_id, type, year,
                den_status, den_status_binary,
                region, latitude, longitude, in_park,
                elevation_m, slope_pct, slope_aspect,
                proj_age_class_cd_1,
                prop_forest_60m, dist_lt40, dist_gt40, dist_road,
                age_class_1:road_density_m2)

# Filter to only 2019:2023
full <- full[which(full$year %in% c(2019:2024)), ]

#full <- na.omit(full) # this eliminates a lot of dens with incomplete DEM (slope, elevation, etc.) data

# Rename park variable so it's easier to tell what it is on plots
full$in_park <- ifelse(full$in_park, "in_park", "not_in_park")


##### Distance from edge #####
# Next, make just one 'distance from edge' variable
full$dist_from_edge <- ifelse(full$dist_lt40 > 0, full$dist_lt40, full$dist_gt40)
#hist(full$dist_from_edge)
full$log_dist_from_edge <- log(full$dist_from_edge + 1)
#hist(full$log_dist_from_edge)

# Next, say if it's in old, new, or edge of forest.
full <- full |> dplyr::mutate(dist_lt40 = round(dist_lt40, 0),
                              dist_gt40 = round(dist_gt40, 0),
                              age = dplyr::case_when((dist_lt40 == dist_gt40) ~ "on_edge",
                                               (dist_lt40 > dist_gt40) ~ "within_old",
                                               (dist_lt40 < dist_gt40) ~ "within_young"))

```


---

`r paste0(round(sum(pseudo_dens$in_park) / nrow(pseudo_dens) * 100, 0), "%")` of the randomly sampled 'pseudo dens' fall within park lands or protected areas, in contrast to only `r paste0(round(sum(dens$in_park) / nrow(dens) * 100, 0), "%")` of the dens sampled in this study.


```{r pseudo map, eval = TRUE}
##### Map #####

# Simplify study_area shape - so it plots faster
study_area <- rmapshaper::ms_simplify(study_area)

# Set up our map bounding box
bbox <- st_bbox(study_area)
bbox[1:2] <- bbox[1:2] - 10000 # add a 10km buffer to our bounding box
bbox[3:4] <- bbox[3:4] + 10000 # add a 10km buffer to our bounding box

# Pull BC shapefile from rnaturalearth
bc <- rnaturalearth::ne_states(country = "canada")
bc <- bc[bc$name == "British Columbia", ]
bc <- st_transform(bc, 3005) # BC Albers projection
bc <- st_crop(bc, bbox) # crop to our bounding box area

# Plot time!
ggplot() +
  geom_sf(data = bc, fill = "grey") +
  geom_sf(data = study_area, fill = "#a4a4a4", color = "#4a4a4a") +
  geom_sf(data = parks, fill = "lightgreen", alpha = 0.6) +
  geom_sf(data = full,
          aes(shape = in_park,
              color = type)) +
  scale_color_manual(name = "Data Type",
                     values = c("black", "#de0ae8")) +
  scale_shape(name = "Location", labels = c("In a park/protected area", "Outside a park/protected area")) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_sf(xlim = c(bbox[1], bbox[3]),
           ylim = c(bbox[2], bbox[4])) +
  labs(caption = "In darker grey, the study area. Green indicates Provincial/Federal parks or proteceted areas.") +
  theme(panel.background = element_rect(fill = "transparent",
                                  colour = NA_character_)) # necessary to avoid drawing panel outline

# Paper figure with no pseudo samples:
# ggplot() +
#     geom_sf(data = bc, fill = "grey") +
#     geom_sf(data = study_area, fill = "#a4a4a4", color = "#4a4a4a") +
#     geom_sf(data = parks, fill = "lightgreen", alpha = 0.6) +
#     geom_sf(data = dens,
#             aes(shape = in_park),
#             fill = "grey15",
#             color = "grey90") +
#     scale_shape_manual(name = "Location", values = c(21, 24), labels = c("Outside a park/protected area", "In a park/protected area")) +
#     scale_x_continuous(expand = c(0, 0)) +
#     scale_y_continuous(expand = c(0, 0)) +
#     coord_sf(xlim = c(bbox[1], bbox[3]),
#              ylim = c(bbox[2], bbox[4])) +
#     labs(caption = "In darker grey, the study area. Green indicates Provincial/Federal parks or proteceted areas.") +
#     theme(panel.background = element_rect(fill = "transparent",
#                                           colour = NA_character_), # necessary to avoid drawing panel outline
#           legend.position = c(0.8, 0.87),
#           legend.background = element_rect(color = NA, fill = NA),)
```

---

## Comparing pseudo data to real data

```{r real v pseudo prop forest}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type, 
             y = prop_forest_60m,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("Pseudo", "Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  labs(x = "Data Type",
       y = "Proportion Forested (GIS verified values)",
       title = "Data Type vs. % Forested (GIS verified)")
```

---

## Comparing pseudo data to real data

```{r real v pseudo prop forest in parks}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type), 
             y = prop_forest_60m,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  labs(x = "Data Type",
       y = "Proportion Forested (GIS verified values)",
       title = "Data Type vs. % Forested (GIS verified)",
       subtitle = "Comparing values inside vs outside parks/protected areas")
```

---

## Comparing pseudo data to real data

```{r real v pseudo dist_lt40}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type, 
             y = dist_lt40,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("Pseudo", "Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to <40 (GIS verified values)",
       title = "Data Type vs. Distance to <40 yo forest (GIS verified values)") 
```

---

## Comparing pseudo data to real data

```{r real v pseudo dist_lt40 in parks}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type), 
             y = dist_lt40,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to <40 (GIS verified values)",
       title = "Data Type vs. Distance to <40 yo forest (GIS verified values)",
       subtitle = "Comparing values inside vs outside parks/protected areas") 
```

---

## Comparing pseudo data to real data

```{r real v pseudo dist_gt40}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type, 
             y = dist_gt40,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("Pseudo", "Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to >40 (GIS verified values)",
       title = "Data Type vs. Distance to >40 yo forest (GIS verified values)") 
```

---

## Comparing pseudo data to real data

```{r real v pseudo dist_gt40 in parks}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type), 
             y = dist_gt40,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to >40 (GIS verified values)",
       title = "Data Type vs. Distance to >40 yo forest (GIS verified values)",
       subtitle = "Comparing values inside vs outside parks/protected areas") 
```

---

## Comparing pseudo data to real data

```{r real v pseudo dist_road}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type, 
             y = dist_road,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("Pseudo", "Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to nearest road (GIS verified values)",
       title = "Data Type vs. Distance to nearest road (GIS verified values)") 
```

---

## Comparing pseudo data to real data

```{r real v pseudo dist_road in parks}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type), 
             y = dist_road,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to nearest road (GIS verified values)",
       title = "Data Type vs. Distance to nearest road (GIS verified values)",
       subtitle = "Comparing values inside vs outside parks/protected areas") 
```

---

## Comparing pseudo data to real data

```{r real v pseudo dist from edge}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type, 
             y = dist_from_edge,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("Pseudo", "Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to forest edge (GIS verified values)",
       title = "Data Type vs. Distance to forest edge (GIS verified values)") 
```

---

## Comparing pseudo data to real data

```{r real v pseudo dist from edge in parks}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type), 
             y = dist_from_edge,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = 'log10') +
  annotation_logticks() +
  labs(x = "Park Status",
       y = "log Distance to forest edge (GIS verified values)",
       title = "Park Status vs. Distance to forest edge (GIS verified values)",
       subtitle = "Comparing values inside vs outside parks/protected areas")
```

---

## Comparing pseudo data to real data

Let's revisit the original figure from a few (dozen) slides ago...

```{r, echo = FALSE, fig.width = 10, fig.height=6, dev.args=list(bg="transparent")}
prop_1km |>  
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 3:11, names_to = "age_class", names_prefix = "age_class_") |>
  dplyr::mutate(age_class = factor(age_class, levels = c(1:9))) |>
  # Then summarize the mean % age class by year 
  dplyr::group_by(year, age_class) |> 
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  scale_fill_light(reverse = TRUE) +
  labs(title = "Real data age classes",
       y = "%") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

Zoom in to 2020-2024, so it lines up with pseudo data...

```{r prct age class 1.5 km 2020-2024, echo = FALSE, fig.width = 10, fig.height=6, dev.args=list(bg="transparent")}
prop_1km |>  
  # Filter to 2020-2024
  dplyr::filter(year %in% c(2020:2024)) |>
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 3:11, names_to = "age_class", names_prefix = "age_class_") |>
  dplyr::mutate(age_class = factor(age_class, levels = c(1:9))) |>
  # Then summarize the mean % age class by year 
  dplyr::group_by(year, age_class) |> 
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  scale_fill_light(reverse = TRUE) +
  labs(title = "Real data age classes",
       y = "%") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

... and compare it to the *very* static age classes around pseudo data.

```{r pseudo prct age class 1.5km 2020-2024, echo = FALSE, fig.width = 10, fig.height=6, dev.args=list(bg="transparent")}
pseudo_prct |>  
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 4:12, names_to = "age_class", names_prefix = "age_class_") |>
  dplyr::mutate(age_class = factor(age_class, levels = c(1:9))) |>
  # Then summarize the mean % age class by year 
  dplyr::group_by(year, age_class) |> 
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  scale_fill_light(reverse = TRUE) +
  labs(title = "Pseudo data age classes",
       y = "%") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

```{r real v pseudo road_density_m2}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type,
             y = road_density_m2,
             color = type)) +
  geom_jitter() +
  geom_boxplot(fill = NA) + 
  scale_y_log10() +
  annotation_logticks(side = "l") +
  geom_signif(comparisons = list(c("Pseudo", "Real")),
              map_signif_level = TRUE) +
  scale_color_bright() +
  labs(x = "Data Type",
       y = "Road density",
       title = "Data Type vs. Road Density",
       caption = "m2 of road surface within 1.5 km of the den") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

```{r real v pseudo road_density_m2 in parks}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type),
             y = road_density_m2,
             color = type)) +
  geom_jitter() +
  geom_boxplot(fill = NA) + 
  scale_y_log10() +
  annotation_logticks(side = "l") +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")),
              map_signif_level = TRUE) +
  scale_color_bright() +
  labs(x = "Data Type",
       y = "Road density",
       title = "Data Type vs. Road Density",
       caption = "m2 of road surface within 1.5 km of the den",
       subtitle = "Comparing values inside vs outside parks/protected areas") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

```{r real v pseudo elevation}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type,
             y = elevation_m,
             color = type)) +
  geom_jitter() +
  geom_boxplot(fill = NA) + 
  geom_signif(comparisons = list(c("Pseudo", "Real")),
              map_signif_level = TRUE) +
  scale_color_bright() +
  labs(x = "Data Type",
       y = "Elevation (m)",
       title = "Data Type vs. Elevation (m)") +
  theme_minimal()
```


---

## Comparing pseudo data to real data

```{r real v pseudo slope}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type,
             y = slope_pct,
             color = type)) +
  geom_jitter() +
  geom_boxplot(fill = NA) + 
  geom_signif(comparisons = list(c("Pseudo", "Real")),
              map_signif_level = TRUE) +
  scale_color_bright() +
  labs(x = "Data Type",
       y = "Slope grade (%)",
       title = "Data Type vs. Slope grade (%)") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

```{r real v pseudo aspect}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type,
             y = slope_aspect,
             color = type)) +
  geom_jitter() +
  geom_boxplot(fill = NA) + 
  geom_signif(comparisons = list(c("Pseudo", "Real")),
              map_signif_level = TRUE) +
  scale_color_bright() +
  labs(x = "Data Type",
       y = "Slope aspect",
       title = "Data Type vs. Slope aspect") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

Takeaways: 
- Randomly sampled points on the landscape are overwhelmingly more likely to have 100% forest coverage within 60 meters than our bear dens.
- The mean distance to recent cutblocks (forest <40 yo) is **significantly higher** for randomly sampled points than for our bear dens.
- For both random data points and bear dens, they are both more likely to be within a patch of mature forest (>40 yo) than not.
- The mean distance to nearest road is **significantly higher** for randomly sampled points than for our bear dens.
- Randomly sampled points, on average, have a higher proportion of old growth forest (age class > 7) within 1.5km than our bear dens.
- Our bears live in **dynamic landscapes**!

---

## Comparing pseudo data to real data

Ultimately, I think it's safe to say we *do not* have a random sample of dens, when it comes to both forestry treatments and geography.

---

# Overall data summary

Good news:
- Considering the amount of effort it takes to collect this data, we have a large sample size across a large swath of the province
- This is the first dataset of its kind (to our knowledge)
- We can supplement this data with the huge backlog of camera data

Limitations:
- We don't have a large sample size -> low statistical power
- We don't have much variation between our various variables
- We don't have a representative (random) sample
- Uneven sampling effort across years and regions

---
class: center, middle, inverse

# Our research questions

Now we have had a nice and detailed tour of the data. What are our research questions? What can we try to answer with this data?

---

# Our research questions

In a nutshell:

1. Does the stand condition around the den influence den activity (Active vs. Not active)?
2. Do non-forestry conditions (e.g., den characteristics) influence den activity?
3. Does forestry treatement affect windthrow impacts?
4. Does current management align with recommendations?

---

# Our research questions

In a nutshell:

**1. Does the stand condition around the den influence den activity (Active vs. Not active)?**
2. Do non-forestry conditions (e.g., den size, geography) influence den activity?
3. Does windthrow affect den activity?
4. Does current management align with recommendations?

---
class: center, middle, inverse

# Question 1: Does stand condition affect den activity?

Let's focus on this one.

---

## Question 1

**Question:** How does stand-level condition, including distance to road, proportion forested, and distance to edge, and landscape-level condition (road density, proportion <40 years, proportion >250 years within 1.5km), relate to den use the following winter?

---

## Question 1

**Question:** How does stand-level condition, including distance to road, proportion forested, and distance to edge, and landscape-level condition (road density, proportion <40 years, proportion >250 years within 1.5km), relate to den use the following winter?

**Prediction:** The likelihood of den use over time is positively correlated with distance to <40 years, distance to road, proportion forested, and negatively correlated with distance to >40 years. Landscape condition may have different responses based on condition; at very low road density, and low <40 years, and high >250 years, den use may be less correlated with stand-level condition as we presume more options for bear to use, which means den use may be lower or more sensitive to stand-level variation.

---

## Question 1

Candidate models:

```
den status ~ year                # control for yearly variation in bear activity
den status ~ region              # do dens have different usage by region?
den status ~ proportion forested # do dens with more intact forest have more activity?
den status ~ distance <40        # do dens further from cutblocks have more activity?
den status ~ distance >40        # do dens further from old growth have less activity?
den status ~ distance to road    # do dens further from roads have more activity?
den status ~ road density        # do dens with higher road density have less activity?
den status ~ stand age           # do dens in older stand age have more activity?
den status ~ % old growth        # do dens with higher % old growth nearby have more activity?
den status ~ % new growth        # do dens with higher % new growth nearby have less activity?

# + interactions with stand age
den status ~ distance to road * stand age # does distance to road matter in old vs young stands?
```

Though, note that all models include `+ age + year` to control for whether the den is in intact mature forest vs a cutblock plus control for yearly variation in activity.

---

## Question 1

In addition to these simple one variable models, we also tried a "kitchen sink" approach, with all non-correlated variables within a single model:

```
# Kitchen sink 1
den status ~ year + region + proportion forested + 
             distance to edge * stand age + 
             road density

# Kitchen sink 2
den status ~ year + region + proportion forested +
             distance to road * stand age
```

---

## Question 1

Data summary: 
- Colinear model terms are excluded from the full "kitchen sink" model.
- Data are strictly filtered down to "Active" and "Not Active" dens where we _for sure_ know the den status. I.e., exluding "Active within past 4 years" or "Unknown" status dens.

---

## Question 1

By far and away, our base model `model00` is consistently one of the top models, in any variation of models we tried.

```{r den status models}
# The modeling data
dat <- f_analysis[f_analysis$den_status_binary %in% c("Active", "Not Active") & f_analysis$den_status %in% for_sure_dens, ]

# Confirm that a strict vs lenient "for sure dens" doesn't change the results!
#dat <- f_analysis[f_analysis$den_status_binary %in% c("Active", "Not Active"), ]

# Confirm that using the regular `f` dataset (the one that DOESN'T match to 
# previous years' forestry) produces results that don't make sense
# It still produces the same top model, but 2022-2024 show HUGE
# confidence intervals. Anything <2020 is cut out entirely, bc it's not
# matched to GIS. All-in-all better to use `f_analysis`.
# dat <- f_full[f_full$den_status_binary %in% c("Active", "Not Active") & f_full$den_status %in% for_sure_dens, ]
# dat <- sf::st_drop_geometry(dat)
# dat$dist_lt40 <- dat$v_dist_lt40
# dat$dist_gt40 <- dat$v_dist_gt40
# dat$dist_road <- dat$v_dist_road

dat <- dat[, c("den_status_binary", "den_id",
               "year",
               "age",
               "hair_in_bed", # will be used in th next set of models
               "region", ##"latitude", "longitude",
               #"elevation_m", # some missing cases?
               "dist_lt40", "dist_gt40", "dist_from_edge", "dist_road",
               "v_prop_forest_60m", "log_dist_lt40", "log_dist_gt40", "log_dist_road",
               "log_dist_from_edge",
               "lt_3", "gt_8",
               "road_density_m2"#,
               #"forestry_treatment_desc" # many missing cases
               )]
dat <- sf::st_drop_geometry(dat)

# Don't know why some of these are still NA
dat[["hair_in_bed"]][is.na(dat$hair_in_bed)] <- "Unknown" # assume unknown if hair == NA
dat$age <- ifelse(dat$dist_lt40 > 0, "within_old", "within_young")
dat$dist_from_edge <- ifelse(dat$dist_lt40 == 0, dat$dist_gt40, dat$dist_lt40)
dat$log_dist_lt40 <- log(dat$dist_lt40 + 1)
dat$log_dist_gt40 <- log(dat$dist_gt40 + 1)
dat$log_dist_from_edge <- log(dat$dist_from_edge + 1)

dat <- dat[complete.cases(dat),]

dat <- dat[dat$dist_road <= 2000, ]

# Convert den_status_binary to 0 or 1
dat$den_status_binary <- ifelse(dat$den_status_binary == "Active", 1, 0)

# Let's drop "on_edge" bc it's perfectly == 0 in distance.
#dat <- dat[which(dat$age != "on_edge"),]
# JK - in this case, just categorize it as 'within young' because
# the kitchen sink model was the best fit, and don't wanna show
# NAs in our results summary table.
dat[["age"]][dat$age == "on_edge"] <- "within_young"
dat$age <- factor(dat$age, levels = c("within_young", "within_old"))

# Remove any lingering models in the environment
rm(list=ls(pattern = "model0|model1"))

# Fit the models!
# Just the basics - each forest metric - effectively same as examining boxplots for significance
model00 <- glm(den_status_binary ~ year, data = dat, family = binomial)
model0r <- glm(den_status_binary ~ region + year, data = dat, family = binomial)
#model0p <- glm(den_status_binary ~ forestry_treatment_desc + year, data = dat, family = binomial)
model0a <- glm(den_status_binary ~ v_prop_forest_60m + age + year, data = dat, family = binomial)
model0b <- glm(den_status_binary ~ dist_lt40 + year, data = dat, family = binomial) # can't have age in this!!!
model0c <- glm(den_status_binary ~ dist_gt40 + year, data = dat, family = binomial) # can't have age in this!!
model0d <- glm(den_status_binary ~ age + year, data = dat, family = binomial)
model0e <- glm(den_status_binary ~ dist_from_edge + age + year, data = dat, family = binomial)
model0f1 <- glm(den_status_binary ~ dist_from_edge * age + year, data = dat, family = binomial)
#model0f2 <- glm(den_status_binary ~ dist_from_edge * age * year, data = dat, family = binomial)
#model0f3 <- glm(den_status_binary ~ dist_from_edge * forestry_treatment_desc + year, data = dat, family = binomial)
model0g1 <- glm(den_status_binary ~ dist_road + age + year, data = dat, family = binomial)
model0g2 <- glm(den_status_binary ~ dist_road * age + year, data = dat, family = binomial)
#model0g3 <- glm(den_status_binary ~ dist_road * age * year, data = dat, family = binomial)
#model0h <- glm(den_status_binary ~ dist_road * forestry_treatment_desc + year, data = dat, family = binomial)
model0i <- glm(den_status_binary ~ gt_8 + age + year, data = dat, family = binomial)
model0j <- glm(den_status_binary ~ lt_3 + age + year, data = dat, family = binomial)
model0k <- glm(den_status_binary ~ road_density_m2 + age + year, data = dat, family = binomial)
model0l <- glm(den_status_binary ~ gt_8 + dist_lt40 + age + year, data = dat, family = binomial)
model0m <- glm(den_status_binary ~ gt_8 + v_prop_forest_60m + age + year, data = dat, family = binomial)
model0n <- glm(den_status_binary ~ road_density_m2 + dist_road + age + year, data = dat, family = binomial)

model1a <- glm(den_status_binary ~ year + v_prop_forest_60m + dist_from_edge * age + road_density_m2, data = dat, family = binomial)
model1b <- glm(den_status_binary ~ year + v_prop_forest_60m + dist_road * age, data = dat, family = binomial)

models_names <- ls()[grep("model0|model1", ls())]
models_list <- lapply(models_names, get)
names(models_list) <- models_names
bbmle::AICtab(models_list, weights = TRUE)

```

```{r, include=FALSE}
# Chopping up into smaller tables for publication
base_models <- models_list[names(models_list) %in% c("model00", "model0r")]
stand_models <- models_list[names(models_list) %in% c("model0a", "model0b", "model0c",
                                                      "model0d", "model0e", "model0f1",
                                                      "model0g1", "model0g2",
                                                      "model1a", "model1b")]
landscape_models <- models_list[names(models_list) %in% c("model0i", "model0j", "model0k",
                                                          "model0l", "model0m", "model0n")]
#full_models <- models_list[names(models_list) %in% c("model1a", "model1b")]


bbmle::AICtab(base_models, weights = TRUE, base = TRUE)
bbmle::AICtab(stand_models, weights = TRUE, base = TRUE)
bbmle::AICtab(landscape_models, weights = TRUE, base = TRUE)

```

---

## Question 1

`model00` happens to be the base model that simply tries to control for decreases in bear den activity (because of low rates of reuse) as a result of more dens monitored over time...

```{r}
summary(model00)
```

---

## Question 1

```{r n field visits per year 2}
f |> 
  dplyr::mutate(year = lubridate::year(date_inspected)) |>
  ggplot(aes(x = year, 
             fill = den_status_binary)) +
  geom_bar(position = "stack") +
  scale_x_continuous(breaks = 2014:2024) +
  labs(x = "Year",
       y = "N field visits",
       title = "Number of field visits per year") +
  theme_minimal() 
```

---

## Question 1

```{r n active per year}
f |> 
  dplyr::filter(den_status_binary == "Active") |>
  dplyr::mutate(year = lubridate::year(date_inspected)) |>
  ggplot(aes(x = year, 
             fill = den_status_binary)) +
  geom_bar(position = "stack") +
  scale_x_continuous(breaks = 2014:2024) +
  labs(x = "Year",
       y = "N field visits",
       title = "Number of field visits per year") +
  theme_minimal() 
```

---

## Question 1

And it so happens that, because of the really low den re-use rate, as time goes on, the likelihood of a den being active again is quite low. Therefore, as `year` increases, your likelihood of being an "Active" den _decreases_.

```{r effect plot model00, fig.height = 5}
sjPlot::plot_model(model00, type = "pred")
```

---

## Question 1

But what about the top model???

.small-code[
```{r top model summary}
models <- bbmle::AICtab(models_list, weights = TRUE)
top_model <- row.names(as.data.frame(models))[[1]]
summary(get(top_model))
```
]

---

## Question 1: Top Model Summary

As distance from road increases, the chances of being "Active" also go up - even after controlling for `year`.

```{r den status v dist_road pred plot, fig.height = 5}
sjPlot::plot_model(get(top_model), type = "pred", terms = c("dist_road[all]"))
```

---

## Question 1: Top Model Summary

It gets complicated when we look at the interaction with age. There's more to tease out from these results. In short, the distance from the edge of the block matters _more_ in young stands than old.

```{r den status v dist_road x age pred plot, fig.height = 5}
sjPlot::plot_model(get(top_model), type = "pred", terms = c("dist_road[all]", "age"))
```

---

## Question 1: Top Model Summary

The relationship is different between young stands versus old, mature stands. If a den is **close to a road** and **within a cutblock**, it's statistically more likely to be **NOT ACTIVE!**

```{r den status v age x dist_road boxplot, fig.height = 5}
dat |>
  dplyr::mutate(den_status_binary = factor(den_status_binary)) |>
  dplyr::filter(!is.na(age)) |>
ggplot(aes(x = interaction(den_status_binary, age), 
                       y = log_dist_road,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("0.within_young", "1.within_young"),
                                           c("1.within_young", "0.within_old"),
                                           c("0.within_old", "1.within_old")),
                        test = "wilcox.test",
                        map_signif_level = TRUE) +
  ggsignif::geom_signif(comparisons = list(c("0.within_young", "0.within_old")),
                        test = "wilcox.test",
                        map_signif_level = TRUE,
                        y_position = 9.6) +
  ggsignif::geom_signif(comparisons = list(c("0.within_young", "1.within_old")),
                        test = "wilcox.test",
                        map_signif_level = TRUE,
                        y_position = 10.2) +
  scale_y_continuous(breaks = c(1:12)) +
  annotation_logticks(side = "l") +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "LOG Distance to nearest road")
```

---

## Question 1: Top Model 2 Summary

The next-best fit is the model that incorporates distance from mature stands (`dist_gt40`).

.small-code[
```{r}
#top_model2 <- row.names(as.data.frame(models))[[2]]
top_model2 <- "model0c"
summary(get(top_model2))
```
]

---

## Question 1: Top Model 2 Summary

The next-best fit is the model that incorporates distance from mature stands (`dist_gt40`). Not clear what's going on here!

```{r effect plot dist_road x age, fig.height = 5}
sjPlot::plot_model(get(top_model2), type = "pred", terms = c("dist_gt40[all]"))
```


```{r r den status v age x dist_from_edge boxplot, fig.height = 5, echo = FALSE, include = FALSE}
## Keeping this code bc it's handy, but it's no longer in the top model, so not showing it in the slides.

## In general, dens within old/mature stands tend to be further from the cutblock edge, while dens within young/cutblock stands tend to be close to the edge of mature forests. 


dat |>
  dplyr::mutate(den_status_binary = factor(den_status_binary)) |>
  dplyr::filter(!is.na(age)) |>
  ggplot(aes(x = interaction(den_status_binary, age), 
             y = log_dist_from_edge,
             color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("0.within_young", "1.within_young"),
                                           c("1.within_young", "0.within_old"),
                                           c("0.within_old", "1.within_old")),
                        test = "wilcox.test",
                        map_signif_level = TRUE) +
  ggsignif::geom_signif(comparisons = list(c("0.within_young", "0.within_old")),
                        test = "wilcox.test",
                        map_signif_level = TRUE,
                        y_position = 9.6) +
  ggsignif::geom_signif(comparisons = list(c("0.within_young", "1.within_old")),
                        test = "wilcox.test",
                        map_signif_level = TRUE,
                        y_position = 10.2) +
  scale_y_continuous(breaks = c(1:12)) +
  annotation_logticks(side = "l") +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "LOG Distance from Stand Edge")
```

---


## Question 1

When we go more lenient with our strict data criteria, and decide to include "Active within last 4 years" as "Active", rather than "Unknown", we get nearly identical results. 

---

## Question 1 _ish_ (hair model)

Activity status in general is fairly objective and can be difficult to define. There were a fair bit of 'Uknown' den statuses. What if we are interested in seeing whether or not a den was checked out _at all_?

What about modeling the response variable as `hair_in_bed`?

---

## Question 1 _ish_ (hair model)

Activity status in general is fairly objective and can be difficult to define. There were a fair bit of 'Uknown' den statuses. What if we are interested in seeing whether or not a den was checked out _at all_?

What about modeling the response variable as `hair_in_bed`?
- It's more objective than the activity status column.
- But, it simply tells us whether or not a bear has visited the den.

---

## Question 1 _ish_ (hair model)

Candidate models:

```
hair in den ~ year                
hair in den ~ region + age + year           
hair in den ~ proportion forested + age + year 
hair in den ~ distance <40 + age + year        
hair in den ~ distance >40 + age + year        
hair in den ~ distance to road + age + year    
hair in den ~ road density + age + year        
hair in den ~ stand age + age + year           
hair in den ~ % old growth + age + year        
hair in den ~ % new growth + age + year        

# + interactions with stand age
hair in den ~ distance to road * stand age + year 

# + full model
hair in den ~ year + region + proportion forested + 
              distance to edge + stand age + 
              road density
```

---

## Question 1 _ish_ (hair model)

- `year` + `region` explained much of the variance.
- When controlling for `year` and `region`, we get something similar as with the original set of models - distance from >40 yo forest influences hair presence. The *further* from mature stands, the more likely for there to be hair!

.small-code[
```{r hair in bed models}
# Remove previous set of models
rm(list=ls(pattern = "model0|model1"))

# We're going to use the same `dat` as above

# Convert y to 0 or 1
dat$hair_in_bed <- ifelse(dat$hair_in_bed %in% c("Yes", "Yes - Unchanged"), 1, 0)

dat$region <- factor(dat$region, levels = c("VI", "HG"))

# Fit the models!
# Just the basics - each forest metric - effectively same as examining boxplots for significance
model00 <- glm(hair_in_bed ~ year, data = dat, family = binomial)
model0r <- glm(hair_in_bed ~ region + age + year, data = dat, family = binomial)
model0a <- glm(hair_in_bed ~ v_prop_forest_60m + age + region + year, data = dat, family = binomial)
model0b <- glm(hair_in_bed ~ dist_lt40 + age + region + year, data = dat, family = binomial)
model0c <- glm(hair_in_bed ~ dist_gt40 + age + region + year, data = dat, family = binomial)
model0d <- glm(hair_in_bed ~ age + year, data = dat, family = binomial)
model0e <- glm(hair_in_bed ~ dist_from_edge + age + region + year, data = dat, family = binomial)
model0f <- glm(hair_in_bed ~ dist_from_edge * age + region + year, data = dat, family = binomial)
model0g <- glm(hair_in_bed ~ dist_road + age + region + year, data = dat, family = binomial)
model0h <- glm(hair_in_bed ~ dist_road * age + region + year, data = dat, family = binomial)
model0i <- glm(hair_in_bed ~ gt_8 + age + region + year, data = dat, family = binomial)
model0j <- glm(hair_in_bed ~ lt_3 + age + region + year, data = dat, family = binomial)
model0k <- glm(hair_in_bed ~ road_density_m2 + age + region + year, data = dat, family = binomial)
model0l <- glm(hair_in_bed ~ gt_8 + dist_lt40 + age + region + year, data = dat, family = binomial)
model0m <- glm(hair_in_bed ~ gt_8 + v_prop_forest_60m + age + region + year, data = dat, family = binomial)
model0n <- glm(hair_in_bed ~ road_density_m2 + dist_road + age + region + year, data = dat, family = binomial)
model0o <- glm(hair_in_bed ~ dist_lt40 * region + age + region + year, data = dat, family = binomial)

model1 <- glm(hair_in_bed ~ year + region + v_prop_forest_60m + dist_road * age + road_density_m2, data = dat, family = binomial)

models_names <- ls()[grep("model0|model1", ls())]
models_list <- lapply(models_names, get)
names(models_list) <- models_names
#bbmle::AICtab(models_list, weights = TRUE)

summary(model0c)
```
]

---

### Question 1 _ish_ (hair model): overall summary

- `year` + `region` explained much of the variance.
- When controlling for `year` and `region`, we get something similar as with the original set of models - distance from >40 yo forest influences hair presence. The *further* from mature stands, the more likely for there to be hair!

```{r hair in bed top model}
sjPlot::plot_model(model0c, type = "pred", terms = c("dist_gt40[all]", "age", "region"),
                   axis.title = c("distance to mature stands (>40 yo)", "hair in bed"))
```

---

### Question 1 _ish_ (hair model): overall summary

- The next top two, within <2 dAIC, are interesting too. 
- Top predictors are 1) _positive_ relationship with proportion of mature stands on landscape within 1.5 km radius and 2) _negative_ relationship with proportion of immature stands on landscape within 1.5 km radius.

```{r hair in bed gt8}
sjPlot::plot_model(model0i, type = "pred", terms = c("gt_8[all]", "age", "region"),
                   axis.title = c("% MATURE stands within 1.5 km", "hair in bed"))
```

---

### Question 1 _ish_ (hair model): overall summary

- The next top two, within <2 dAIC, are interesting too. 
- Top predictors are 1) _positive_ relationship with proportion of mature stands on landscape within 1.5 km radius and 2) _negative_ relationship with proportion of immature stands on landscape within 1.5 km radius.

```{r hair in bed lt3}
sjPlot::plot_model(model0j, type = "pred", terms = c("lt_3[all]", "age", "region"),
                   axis.title = c("% IMMATURE stands within 1.5 km", "hair in bed"))
```

---

## Question 1

Ways forward?
- Perhaps some sort of weights/error structure can account for year without it "swamping" the model?
- Perhaps a bootstrapping approach to account for uneven years sampling: pull a random year of data - one per each den - then fit the model. Do this 1000x. Take the model averages.
- Perhaps running piecewise models: one for 'pre disturbance' den data, one for 'post disturbance'?
- Non-linear modeling approaches: perhaps a principal components analysis (PCA)?
- And finally, and perhaps most likely, we simply **need a greater sample size.** A priori power analysis indicated we'd need >400 dens sampled, but the modeling dataset is only `r nrow(dat)` data points!

---
class: center, middle, inverse

# Question 2: Do non-forestry conditions influence den activity?

---

## Question 2

**Question:** How do intrinsic den characteristics, such as den cavity size and shape, tree species, or position on the slope relate to den use?

---

## Question 2

**Question:** How do intrinsic den characteristics, such as den cavity size and shape, tree species, or position on the slope relate to den use?

**Prediction:** The likelihood of den use is positively correlated with certain den sizes, tree species, and slopes.

---

For all the following plots, the response variable indicates whether or not the den was *ever* active (`ever_active_yn == TRUE`) or has *never* been active (`ever_active_yn == FALSE`). 
This is done to reduce psuedoreplication (many repeats of static den measurements versus changing den status each year), such that there is one data point per den (single static den measurements versus single "was the den active" response).

---

### Chamber dimensions vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r den status v den measurements, dev.args=list(bg="transparent"), fig.height = 5}
label_names <- c(
  `chamber_width` = "Chamber width",
  `chamber_height` = "Chamber height",
  `chamber_length` = "Chamber length"
)

f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(ever_active_yn, chamber_width, chamber_height, chamber_length) |>
  distinct() |>
  tidyr::pivot_longer(cols = c("chamber_width", "chamber_height", "chamber_length"),
                      names_to = "Measurement",
                      values_to = "cm") |>
  ggplot(aes(x = ever_active_yn,
             y = cm,
             color = ever_active_yn)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("FALSE", "TRUE")),
                        map_signif_level = TRUE) +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) + 
  labs(x = "Has the den ever been active?",
       y = "Measurement (cm)") +
  facet_wrap(~ Measurement, labeller = as_labeller(label_names))
```

---

### Chamber dimensions vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r den status v func entrance width, dev.args=list(bg="transparent"), fig.height = 5}
f_full |>
    group_by(ever_active_yn, entrance_width_functional) |>
    ggplot(aes(x = ever_active_yn, y = entrance_width_functional, color = ever_active_yn)) +
    geom_jitter() +
    geom_boxplot(fill = NA) +
    geom_signif(comparisons = list(c("TRUE", "FALSE")),
                map_signif_level = TRUE) +
    scale_color_bright() +
    labs(x = "Has the den ever been active?",
         y = "Functional entrance width (cm)") +
    theme_minimal()
```

---

### DBH vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r den status v DBH, fig.height = 5}
f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(den_tree_dbh, ever_active_yn) |>
  distinct() |>
  ggplot(aes(x = ever_active_yn, 
             y = den_tree_dbh,
             color = ever_active_yn)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  scale_color_bright() +
  geom_signif(comparisons = list(c("TRUE", "FALSE")), map_signif_level = TRUE) +
  theme_minimal() +
  labs(x = "Has the den ever been active?",
       y = "Den Tree DBH (cm)",
       title = "Den Status vs. Den Tree DBH (cm)",
       subtitle = "Binned into dens that have ever vs never been active.",
       caption = paste0("N = ", length(unique(f$den_id)))
       ) 
```

---

### Den type vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

Root bole type dens disproportionately have more activity.

```{r chisq den status v den type}
chisq <- f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(ever_active_yn, den_type) |>
  distinct() |>
  dplyr::group_by(den_type, ever_active_yn) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = den_type,
                     values_from = n) |>
  tibble::column_to_rownames(var = "ever_active_yn") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

### Den tree species vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

Root bole type dens disproportionately have more activity.

```{r chisq den status v den tree spp}
chisq <- f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(ever_active_yn, den_tree_species) |>
  distinct() |>
  dplyr::group_by(den_tree_species, ever_active_yn) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = den_tree_species,
                     values_from = n) |>
  tibble::column_to_rownames(var = "ever_active_yn") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

### Bed Cup vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

Active dens disproportionately have a bedding cup (makes sense - it's one of the decision criteria).

```{r chisq den status v bed cup}
chisq <- f |>
  dplyr::select(bedding_cup_present, ever_active_yn) |>
  distinct() |>
  dplyr::group_by(bedding_cup_present, ever_active_yn) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = bedding_cup_present,
                     values_from = n) |>
  tibble::column_to_rownames(var = "ever_active_yn") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

### Hair in Bed vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

Active dens disproportionately have hair in the bed (makes sense - it's one of the decision criteria).

```{r chisq den status v hair in bed}
chisq <- f |>
  dplyr::select(hair_in_bed, ever_active_yn) |>
  distinct() |>
  dplyr::group_by(hair_in_bed, ever_active_yn) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = hair_in_bed,
                     values_from = n) |>
  tibble::column_to_rownames(var = "ever_active_yn") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

### Hair on Entrance vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

Active dens disproportionately have hair on the entrance (makes sense - it's one of the decision criteria).

```{r chisq den status v hair on entrance}
chisq <- f |>
  dplyr::select(hair_on_entrance, ever_active_yn) |>
  distinct() |>
  dplyr::group_by(hair_on_entrance, ever_active_yn) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = hair_on_entrance,
                     values_from = n) |>
  tibble::column_to_rownames(var = "ever_active_yn") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```


---

### Elevation

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r den status v elevation, fig.height = 5}
f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(elevation_m, ever_active_yn) |>
  distinct() |>
  ggplot(aes(x = ever_active_yn, 
             y = elevation_m,
             color = ever_active_yn)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  scale_color_bright() +
  geom_signif(comparisons = list(c("TRUE", "FALSE")), map_signif_level = TRUE) +
  theme_minimal() +
  labs(x = "Has the den ever been active?",
       y = "Elevation (m)",
       title = "Den Status vs. Elevation (m)",
       subtitle = "Binned into dens that have ever vs never been active.",
       caption = paste0("N = ", length(unique(f$den_id)))
       ) 
```

---

### Slope grade (%)

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r den status v slope grade, fig.height = 5}
f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(slope_pct, ever_active_yn) |>
  distinct() |>
  ggplot(aes(x = ever_active_yn, 
             y = slope_pct,
             color = ever_active_yn)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  scale_color_bright() +
  geom_signif(comparisons = list(c("TRUE", "FALSE")), map_signif_level = TRUE) +
  theme_minimal() +
  labs(x = "Has the den ever been active?",
       y = "Slope Grade (%)",
       title = "Den Status vs. Slope (%)",
       subtitle = "Binned into dens that have ever vs never been active.",
       caption = paste0("N = ", length(unique(f$den_id)))
       ) 

```

---

### Slope aspect (degrees)

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r den status v slope aspect, fig.height = 5}
f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(slope_aspect, ever_active_yn) |>
  distinct() |>
  ggplot(aes(x = ever_active_yn, 
             y = slope_aspect,
             color = ever_active_yn)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  scale_color_bright() +
  geom_signif(comparisons = list(c("TRUE", "FALSE")), map_signif_level = TRUE) +
  theme_minimal() +
  labs(x = "Has the den ever been active?",
       y = "Slope Aspect",
       title = "Den Status vs. Slope Aspect",
       subtitle = "Binned into dens that have ever vs never been active.",
       caption = paste0("N = ", length(unique(f$den_id)))
       ) 

```

---

## Question 2

Overall, whether or not a den was ever active during the monitoring period does not appear to be significantly influenced by either den qualities (e.g. chamber width, height) or non-forestry geography (e.g., elevation, slope). 


---
class: center, middle, inverse

# Question 3A: Does forestry condition affect windthrow probability?

# Question 3B: Does windthrow severity affect den activity?

---

## Question 3A

**Question:** How does forestry condition, such as distance from cutblock edge, retention patch size, and harvest status influence the amount of windthrow in a given area?

---

## Question 3A

**Question:** How does forestry condition, such as distance from cutblock edge, retention patch size, and harvest status influence the amount of windthrow in a given area?

**Prediction:** The probability of windthrow occuring within a given area will be greater the closer to a cutblock edge that area is. Locations within smaller retention patch sizes and within 60m of harvest are more likely to have windthrow than locations in larger retention patches and futher from harvest.

```{r windthrow prep, include = FALSE}
# This code block preps the dataframe to run Gavin's windthrow 
# analyses. 

# Order the windthrow codes by severity
f$windthrow_code <- factor(f$windthrow_code, 
                           levels = c("None", 
                                      "At risk", 
                                      "Windthrow adjacent (>5%)",
                                      "Windthrow adjacent - catastrophic (>25%)",
                                      "Windthrow block access",
                                      "Den tree top blown",
                                      "Den tree blown over"))

# Create a patch variable that orders forestry treatments
# by patch size + makes shorter labels for plots
f$patch <- factor(f$forestry_treatment_desc,
                  levels = c("Contiguous Forest within >60m radius",
                             "Large retention patch (30-60m radius or 2830-11300 m2)",
                             "Medium retention patch (10-30m radius or 314-2830m2)",
                             "Edge of block (within 5m)",
                             "Other"),
                  labels = c("Contiguous",
                             "Large RP",
                             "Med. RP",
                             "Edge (<5 m)",
                             "Other"))

# Create a harvested varianle
f$harvested <- ifelse((f$f_prop_forest_60m < 100 & (f$f_dist_lt40 <= 60 | f$f_dist_road <= 60)),
                      "Harvested",
                      "Not harvested")
f$harvested_yn <- ifelse(f$harvested == "Harvested",
                         TRUE,
                         FALSE)

# Categorize windthrow codes into severity categories
# f df
f <- f |>
  dplyr::mutate(windthrow_sev = dplyr::case_when(windthrow_code == "None" ~ "Insignificant",
                                                 windthrow_code == "At risk" ~ "At risk",
                                                 windthrow_code == "Windthrow adjacent (>5%)" ~ "Moderate",
                                                 windthrow_code %in% c("Windthrow adjacent - catastrophic (>25%)",
                                                                       "Windthrow block access",
                                                                       "Den tree top blown",
                                                                       "Den tree blown over") ~ "Severe",
                                                 TRUE ~ NA))

f$windthrow_sev <- factor(f$windthrow_sev,
                          levels = c("Insignificant",
                                     "At risk",
                                     "Moderate",
                                     "Severe"))

# f_analysis df
f_analysis <- f_analysis |>
  dplyr::mutate(windthrow_sev = dplyr::case_when(windthrow_code == "None" ~ "Insignificant",
                                                 windthrow_code == "At risk" ~ "At risk",
                                                 windthrow_code == "Windthrow adjacent (>5%)" ~ "Moderate",
                                                 windthrow_code %in% c("Windthrow adjacent - catastrophic (>25%)",
                                                                       "Windthrow block access",
                                                                       "Den tree top blown",
                                                                       "Den tree blown over") ~ "Severe",
                                                 TRUE ~ NA))

f_analysis$windthrow_sev <- factor(f_analysis$windthrow_sev,
                          levels = c("Insignificant",
                                     "At risk",
                                     "Moderate",
                                     "Severe"))

# NOTE THIS IS DIFFERENT TO THE `distance_from_edge` VARIABLE
# CREATED ELSEWHERE IN THIS DOCUMENT
# The previous analysis lumped together distance from edge
# to <40 yo forest and distance to road. They were both
# considered 'disturbed' forest edges susceptible to windthrow.

# Choose whichever one is the lower value
f$dist_to_edge <- ifelse(f$f_dist_lt40 < f$f_dist_road,
                         f$f_dist_lt40,
                         f$f_dist_road)
```

---

Windthrow is categorized by estimating the proportion of trees within a 60m radius of a given point (lat, lon of a den) that are windthrown.

```{r n windthrow code}
ggplot(f,
       aes(x = windthrow_code)) +
  geom_bar() +
  labs(x = "Windthrow Code",
       y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

---

Windthrow is categorized by estimating the proportion of trees within a 60m radius of a given point (lat, lon of a den) that are windthrown.

```{r prct windthrow density plot}
summary(f$windthrow_prct)

ggplot(f,
       aes(x = windthrow_prct)) +
  geom_density() +
  labs(x = "Windthrow (%)",
       y = "Density") +
  scale_x_continuous(limits = c(0, 100)) +
  theme_minimal()
```

---

Windthrow is categorized by estimating the proportion of trees within a 60m radius of a given point (lat, lon of a den) that are windthrown.

```{r prct windthrow v patch type}
f[!is.na(f$patch), ] |>
  ggplot(aes(x = patch,
             y = windthrow_prct)) +
  geom_jitter() +
  geom_boxplot(fill = NA) +
  labs(x = "Patch size (category)",
       y = "Windthrow (%)") +
  scale_y_continuous(limits = c(0, 100)) +
  theme_minimal()
```

---

Harvest status is determined by the % tree coverage within 60m of a given point. If a road cuts through the forest OR there is forest <40 years old within 60m of that point, it counts as "harvested". Areas within 60m naturally unforested areas, such as the edge of a lake, would NOT count as "harvested" under these critera.

```{r n harvest status fig}
ggplot(f[!is.na(f$harvested), ],
       aes(x = harvested)) +
  geom_bar() +
  labs(x = "Harvest status", 
       y = "Count") +
  theme_minimal()
```

---

Harvested areas have significantly higher % windthrow.

```{r prct windthrow v harvest status}
f[!is.na(f$harvested), ] |>
  ggplot(aes(x = harvested,
           y = windthrow_prct)) +
  geom_jitter() +
  geom_boxplot(fill = NA) +
  geom_signif(comparisons = list(c("Harvested", "Not harvested")),
              map_signif_level = TRUE,
              test = "wilcox.test") +
  labs(x = "Harvest status", 
       y = "Windthrow (%)") +
  theme_minimal()
```

---

Distance to edge is the distance to any hard forest edge caused by harvest activity, including distance to <40 yo forest or distance to road (whichever was closer).

```{r prct windthrow v dist to edge}
ggplot(f[which(f$dist_to_edge < 6000), ],
       aes(x = dist_to_edge,
           y = windthrow_prct)) +
  #scale_x_log10() +
  scale_y_continuous(limits = c(0, 100)) +
  geom_point() + 
  labs(title = "Distance to Edge vs Windthrow (%)",
       x = "Distance to Edge",
       y = "Windthrow within 60m radius (%)") +
  theme_minimal()
```

---

```{r prct windthrow v dist to edge w trendline}
dat <- f[,c("windthrow_prct", "dist_to_edge")]
dat <- na.omit(dat)
dat$log_dist_to_edge <- log(dat$dist_to_edge + 1)
dat <- dat[dat$dist_to_edge < 6000, ]
dat <- unique(dat) # Remove all the duplicates

# It's not perfect, but it'll work for the plot
tw <- glmmTMB(formula = windthrow_prct ~ log_dist_to_edge,
               data = dat,
               family = tweedie)
#tw_preds <- predict(tw, dat, type = "response")
ilink <- family(tw)$linkinv   # this is the inverse of the link function, as an R function
pdata <- cbind(dat[,c("windthrow_prct", "log_dist_to_edge")],
               as.data.frame(predict(tw, newdata = dat, type = "link", se.fit = TRUE)))
## Compute 95% confidence interval on link scale & back transform this & model fit to response scale
pdata <- transform(pdata,
                   upper  = ilink(fit + (1.96 * se.fit)),
                   lower  = ilink(fit - (1.96 * se.fit)),
                   fitted = ilink(fit))


pdata |>
  dplyr::mutate(dist_to_edge = exp(log_dist_to_edge) - 1) |>
  ggplot(aes(x = dist_to_edge)) +
  geom_point(aes(y = windthrow_prct),
             color = "black",
             alpha = 0.5,
             shape = 4) + 
  geom_ribbon(aes(ymin = lower,
                  ymax = upper),
              alpha = 0.2) +
  geom_line(aes(y = fitted), color = "red") +
  coord_cartesian(xlim = c(0, 1000)) +
  scale_y_continuous(limits = c(0, 100)) +
  labs(title = "Distance to Edge vs Windthrow (%)",
       x = "Distance to Edge",
       y = "Windthrow within 60m radius (%)") +
  theme_minimal()
```

---

```{r}
summary(tw)
```

---

While there is a relationship between windthrow % and distance to edge, there appears to be no relationship between forest stand age class and windthrow (there were no significant differences between finer groupings of age class, either). 

```{r prct windthrow v age class}
f_full |>
  dplyr::filter(!is.na(age_class)) |>
  dplyr::mutate(age_class = ifelse(age_class == "9: >250",
                                   ">9 (Old growth)",
                                   "<9 (all other stages)")) |>
  ggplot(aes(x = age_class,
             y = windthrow_prct)) +
  geom_jitter() +
  geom_boxplot(fill = NA) +
  geom_signif(comparisons = list(c(">9 (Old growth)", "<9 (all other stages)")),
              map_signif_level = TRUE,
              test = "wilcox.test") +
  labs(x = "Age Class",
       y = "Windthrow (%)") +
  theme_minimal()
```

---

There is a significant relationship between canopy closure and windthrow.

```{r prct windthrow v canopy closure}
ggplot(f_full,
       aes(x = canopy_closure,
           y = windthrow_prct)) +
  geom_point() +
  stat_smooth(method = "lm") +
  scale_x_continuous(limits = c(0, 100)) +
  labs(x = "Canopy closure (%)",
       y = "Windthrow (%)") +
  theme_minimal()
```

---

There is a significant relationship between canopy closure and windthrow.

```{r}
summary(lm(windthrow_prct ~ canopy_closure, data = f_full))
```

---

```{r chisq windthrow severity v harvest status}
chisq <- f |>
  dplyr::select(den_id, windthrow_sev, harvested) |>
  dplyr::filter(windthrow_sev != "At risk") |>
  dplyr::distinct() |> # remove pseudo replicated yearly repeats
  dplyr::select(-den_id) |>
  na.omit() |>
  dplyr::group_by(windthrow_sev, harvested) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = windthrow_sev,
                     values_from = n) |>
  tibble::column_to_rownames(var = "harvested") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()
```

If there has been harvest activity within 60m of a location, windthrow severity goes up (X-squared *p*-value `r ifelse(chisq$p.value < 0.0001, "< 0.0001", paste0("= ", chisq$p.value))`).

```{r windthrow severity v harvest status mosaic plot}
f |> 
  dplyr::select(den_id, windthrow_sev, harvested) |>
  dplyr::filter(windthrow_sev != "At risk") |>
  dplyr::distinct() |> # remove pseudo replicated yearly repeats
  dplyr::select(-den_id) |> 
  droplevels() |>
  na.omit() |>
  ggplot() +
  geom_mosaic(aes(x = product(harvested), 
                  fill = windthrow_sev), 
              alpha = 1) + 
  scale_fill_manual(values = c("forestgreen", "gold", "orange")) +
  labs(y = "Windthrow Severity", 
       x = "Harvest Status") + 
  theme_mosaic() +
  theme(legend.position = "none", 
        axis.title.x = element_text(size = 14, vjust = -0.2), 
        axis.title.y = element_text(size = 14))
```

```{r}
chisq$statistic
```

---

## Question 3B

**Question:** How does windthrow severity influence den activity? 

---

## Question 3B

**Question:** How does windthrow severity influence den activity? 

**Prediction:** Dens within areas of higher windthrow severity are less likely to be active.

---

This question unfortunately is not so straightforward to answer. There does not seem to be a large difference in activity between still-functional den trees in severe vs. unaffected areas. In general, regardless of windthrow state, dens just aren't active very much.

```{r windthrow severity v den status mosaic plot}
f_analysis |> 
  sf::st_drop_geometry() |>
  dplyr::select(den_id, windthrow_sev, den_status_binary) |>
  dplyr::filter(windthrow_sev != "At risk") |>
  dplyr::filter(den_status_binary != "Unknown") |>
  dplyr::distinct() |> # remove pseudo replicated yearly repeats
  dplyr::select(-den_id) |> 
  droplevels() |>
  na.omit() |>
  ggplot() +
  geom_mosaic(aes(x = product(windthrow_sev), 
                  fill = den_status_binary), 
              alpha = 1) + 
  scale_fill_manual(values = c("forestgreen", "gold", "orange")) +
  labs(y = "Den Activity Status",
       x = "Windthrow Severity",
       caption = "'Unknown' den activity statuses were removed for this plot.") +
  theme_mosaic() +
  theme(legend.position = "none", 
        axis.title.x = element_text(size = 14, vjust = -0.2), 
        axis.title.y = element_text(size = 14))
```

---
class: center, middle, inverse

# Question 4: Does current management align with recommendations?

How many dens fall within best practice guidelines?

---

### Dens >75m from the nearest road

```{r n dens 75m from road}
n_dens <- length(unique(f$den_id))

f |>
  dplyr::select(den_id, f_dist_road) |>
  dplyr::filter(!is.na(f_dist_road)) |>
  dplyr::distinct() |>
  dplyr::mutate(over_75 = f_dist_road > 75) |>
  dplyr::group_by(over_75) |>
  dplyr::mutate(n_over_75 = dplyr::n()) |>
  dplyr::ungroup() |> 
  dplyr::mutate(nrows = max(dplyr::row_number())) |>
  ggplot(aes(x = over_75)) +
  geom_bar() +
  geom_text(aes(label = scales::percent(round(n_over_75 / nrows, 2))),
            stat = 'count',
              position = position_dodge(.9), 
              vjust = -0.5, 
              size = 3) + 
  labs(title = "N dens >75m from a road",
          x = "Is the den >75m from a road?",
          y = "N dens",
       caption = paste(n_dens, "dens total")) +
  theme_minimal()
```

---

### Dens >75m from the nearest road

```{r n dens 75m from road x den status}
f |>
  dplyr::select(den_id, den_status_binary, f_dist_road) |>
  dplyr::filter(!is.na(f_dist_road)) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::distinct() |>
  dplyr::mutate(over_75 = f_dist_road > 75) |>
  dplyr::group_by(over_75, den_status_binary) |>
  dplyr::mutate(n_over_75 = dplyr::n()) |>
  dplyr::ungroup() |> 
  dplyr::mutate(nrows = max(dplyr::row_number())) |>
  ggplot(aes(x = over_75,
             fill = den_status_binary)) +
  geom_bar() +
  geom_text(aes(label = scales::percent(round(n_over_75 / nrows, 2))),
            stat = 'count',
              position = position_dodge(.9), 
              vjust = -0.5, 
              size = 3) + 
  scale_fill_bright(name = "Den status") +
  labs(title = "N dens >75m from a road",
       x = "Is the den >75m from a road?",
       y = "N dens",
       caption = paste(n_dens, "dens total")) +
  facet_wrap(~ den_status_binary) +
  theme_minimal()
```

---

### Dens >30m from cutblock/new growth

```{r n dens 30m from cutblock}
f |>
  dplyr::select(den_id, f_dist_lt40) |>
  dplyr::filter(!is.na(f_dist_lt40)) |>
  dplyr::distinct() |>
  dplyr::mutate(over_30 = f_dist_lt40 > 30) |>
  dplyr::group_by(over_30) |>
  dplyr::mutate(n_over_30 = dplyr::n()) |>
  dplyr::ungroup() |> 
  dplyr::mutate(nrows = max(dplyr::row_number())) |>
  ggplot(aes(x = over_30)) +
  geom_bar() +
  geom_text(aes(label = scales::percent(round(n_over_30 / nrows, 2))),
            stat = 'count',
            position = position_dodge(.9), 
            vjust = -0.5, 
            size = 3) + 
  labs(title = "N dens >30m from a cutblock",
       x = "Is the den >30m from a cutblock (forest <40 years old)?",
       y = "N dens",
       caption = paste(n_dens, "dens total")) +
  theme_minimal()
```

---

### Dens >30m from cutblock/new growth

```{r n dens 30m from cutblock x den status}
f |>
  dplyr::select(den_id, den_status_binary, f_dist_lt40) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::filter(!is.na(f_dist_lt40)) |>
  dplyr::distinct() |>
  dplyr::mutate(over_30 = f_dist_lt40 > 30) |>
  dplyr::group_by(over_30, den_status_binary) |>
  dplyr::mutate(n_over_30 = dplyr::n()) |>
  dplyr::ungroup() |> 
  dplyr::mutate(nrows = max(dplyr::row_number())) |>
  ggplot(aes(x = over_30,
             fill = den_status_binary)) +
  geom_bar() +
  geom_text(aes(label = scales::percent(round(n_over_30 / nrows, 2))),
            stat = 'count',
            position = position_dodge(.9), 
            vjust = -0.5, 
            size = 3) + 
  scale_fill_bright(name = "Den status") +
  facet_wrap(~ den_status_binary) +
  labs(title = "N dens >30m from a cutblock",
       x = "Is the den >30m from a cutblock (forest <40 years old)?",
       y = "N dens",
       caption = paste(n_dens, "dens total")) +
  theme_minimal()
```

---

### Dens with 100% forest retention in a 60m radius

```{r n dens 100prct forest within 60m}
f |>
  dplyr::select(den_id, f_prop_forest_60m) |>
  dplyr::filter(!is.na(f_prop_forest_60m)) |>
  dplyr::distinct() |>
  dplyr::mutate(allforest = f_prop_forest_60m == 100) |>
  dplyr::group_by(allforest) |>
  dplyr::mutate(n_allforest = dplyr::n()) |>
  dplyr::ungroup() |> 
  dplyr::mutate(nrows = max(dplyr::row_number())) |>
  ggplot(aes(x = allforest)) +
  geom_bar() +
  geom_text(aes(label = scales::percent(round(n_allforest / nrows, 2))),
            stat = 'count',
            position = position_dodge(.9), 
            vjust = -0.5, 
            size = 3) + 
  labs(title = "N dens 100% forested within 60m",
       x = "Is the den 100% forested in a 60m radius?",
       y = "N dens",
       caption = paste(n_dens, "dens total")) +
  theme_minimal()
```

---

### Dens with 100% forest retention in a 60m radius

```{r n dens 100prct forest within 60m x den status}
f |>
  dplyr::select(den_id, den_status_binary, f_prop_forest_60m) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::filter(!is.na(f_prop_forest_60m)) |>
  dplyr::distinct() |>
  dplyr::mutate(allforest = f_prop_forest_60m == 100) |>
  dplyr::group_by(allforest, den_status_binary) |>
  dplyr::mutate(n_allforest = dplyr::n()) |>
  dplyr::ungroup() |> 
  dplyr::mutate(nrows = max(dplyr::row_number())) |>
  ggplot(aes(x = allforest,
             fill = den_status_binary)) +
  geom_bar() +
  geom_text(aes(label = scales::percent(round(n_allforest / nrows, 2))),
            stat = 'count',
            position = position_dodge(.9), 
            vjust = -0.5, 
            size = 3) + 
  scale_fill_bright(name = "Den status") +
  facet_wrap(~ den_status_binary) +
  labs(title = "N dens 100% forested within 60m",
       x = "Is the den 100% forested in a 60m radius?",
       y = "N dens",
       caption = paste(n_dens, "dens total")) +
  theme_minimal()
```

---

### Dens within each patch size class

```{r n dens patch type}
n_dens <- length(unique(f[["den_id"]][!is.na(f$forestry_treatment_desc)]))
f |>
  dplyr::select(den_id, den_status_binary, forestry_treatment_desc) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::filter(!is.na(forestry_treatment_desc)) |>
  dplyr::distinct() |>
  dplyr::group_by(forestry_treatment_desc) |>
  dplyr::mutate(n_ftd = dplyr::n()) |>
  dplyr::ungroup() |> 
  dplyr::mutate(nrows = max(dplyr::row_number())) |>
  ggplot(aes(x = forestry_treatment_desc)) +
  geom_bar() +
  geom_text(aes(label = scales::percent(round(n_ftd / nrows, 2))),
            stat = 'count',
            position = position_dodge(.9), 
            vjust = 0.5, 
            hjust = -0.2,
            size = 3) + 
  scale_fill_bright(name = "Den status") +
  labs(title = "N dens by patch size",
       x = "Patch status",
       y = "N dens",
       caption = paste(n_dens, "dens total with enough information to determine patch size")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  coord_flip()
```

---

### Dens within each patch size class

```{r n dens patch type x den status}
f |>
  dplyr::select(den_id, den_status_binary, forestry_treatment_desc) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::filter(!is.na(forestry_treatment_desc)) |>
  dplyr::distinct() |>
  dplyr::group_by(forestry_treatment_desc, den_status_binary) |>
  dplyr::mutate(n_ftd = dplyr::n()) |>
  dplyr::ungroup() |> 
  dplyr::mutate(nrows = max(dplyr::row_number())) |>
  ggplot(aes(x = forestry_treatment_desc,
             fill = factor(den_status_binary))) +
  geom_bar(position = "dodge") +
  geom_text(aes(label = scales::percent(n_ftd / nrows,
                                        accuracy = 0.1)),
            stat = 'count',
            position = position_dodge(.9), 
            vjust = 0.5, 
            hjust = -0.2,
            size = 3) + 
  scale_fill_bright(name = "Den status") +
  labs(title = "N dens by patch size",
       x = "Patch status",
       y = "N dens",
       caption = paste(n_dens, "dens total with enough information to determine patch size")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_y_continuous(limits = c(0, 60)) +
  coord_flip()
```


