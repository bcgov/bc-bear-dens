---
title: "Bear Den Data Summary"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: xaringan-themer.css
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
editor_options: 
  chunk_output_type: console
---

```{r xaringan-themer, include = FALSE, warning = FALSE}
library(xaringanthemer)
style_solarized_light(header_color = "#859900")
```

```{css, echo=FALSE}
/* make long codeblocks horizontally scrollable */
.hscroll {
  overflow-x: auto;
  white-space: nowrap;
}
```

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)

# Set working directory to the project folder, so the script can find the targets
#knitr::opts_knit$set(root.dir = rstudioapi::getActiveProject())

# Global knitr options
knitr::opts_chunk$set(warning = FALSE, # don't print code warnings in slides 
                      message = FALSE, # don't print code messages in slides
                      echo = FALSE, # don't print the code itself in any of the slides (unless manually overridden)
                      fig.width = 9, # make default figure width 7"
                      fig.align='center', # center align any figures
                      dev = "svg", # make any plots "svg" format (rather than PNG or JPEG for example)
                      dev.args = list(bg = "transparent") # make the background of all plots transparent
                      ) 

# Load packages
library(targets)  # load up data targets
library(sf)       # spatial manipulation
library(leaflet)  # interactive map
library(dplyr)    # data manipulation
library(magrittr) # data manipulation
library(ggplot2)  # plotting
library(ggsignif) # plotting significance/t-test/wilcox test on boxplots
library(khroma)   # plotting color schemes
library(glmmTMB)  # modeling

# Read in tokens
# For this specific markdown file, we need the 'jawg_token' to load
# the nice basemap for the interactive map.
withr::with_dir(rprojroot::find_root('_targets.R'), source("temp/token.R"))

# Load targets
# Since this markdown file isn't actually part of the targets
# pipeline, you need this weird workaround to load a target:
# https://github.com/ropensci/targets/issues/230

# dens = dens metadata (with no field visit info attached)
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(dens))

# f = field visits table (with no den metadata attached)
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(f))

# f_analysis = field visits data, rearranged such that the current year's
# den status is matched to *the previous year's* forestry data
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(f_analysis))

# prop_1km = proportion forested within 1.5km
prop_1km <- withr::with_dir(rprojroot::find_root('_targets.R'),
                            tar_read(prct_age_class_1.5km)) # use `tar_read` when you want to read a target but assign it to a new object name in the R environment

# road_density = road density around each den
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(road_density))
road_density <- merge(f[3], road_density, all.x = TRUE) # merge in the other sample id's (with zero road density) into road_density dataset
road_density$road_density_m2 <- ifelse(is.na(road_density$road_density_m2), 0, road_density$road_density_m2)

# Define list of "for sure dens"
for_sure_dens <- c("Active in last denning season", 
                   "Not active in last season",
                   "Not active in last season, but recent use (1-4 seasons)",
                   "Not active in last season, no recent use (>4 seasons)",
                   "No recent evidence of use (>4 seasons)")
```

```{r dens prep, include = FALSE}
# Wrap this up into `clean_bears` func at some point
# Coerce factors
factors <- c("struct_stage", "age_class", "slope_position", "den_type", "den_tree_species", "district")
dens %<>% mutate_at(factors, factor)
# Remove 999
dens %<>%
  mutate(across(where(is.numeric), ~replace(., . == 999, NA)),
         across(where(is.numeric), ~replace(., . == -999, NA)))

# Add latitude, longitude cols to data
dens <- st_transform(dens, 3005) # to BC Albers projection
dens <- cbind(dens, st_coordinates(dens))
names(dens)[grep("X", names(dens))] <- "longitude" # technically easting/northing with BC Albers but shhh
names(dens)[grep("Y", names(dens))] <- "latitude"

# Assign either VI or HG to data, to examine by island
dens$region <- ifelse(dens$latitude > 800000, "HG", "VI")
```

```{r f prep, include = FALSE}
# Rename forestry columns to more consistent/easier to use names
f <- dplyr::rename(f,
              "nearest_tree_m" = "distance_nearest_tree_field",
              "f_prop_forest_60m" = "proportion_forested_field",
              "v_prop_forest_60m" = "proportion_forested",
              "f_dist_lt40" = "distance_less40yr_forest_field", 
              "v_dist_lt40" = "v_distance_less40yr_forest",
              "f_dist_gt40" = "distance_grtr40yr_forest_field", 
              "v_dist_gt40" = "v_distance_grtr40year_forest", 
              "f_dist_road" = "distance_nearest_road", 
              "v_dist_road" = "v_distance_nearest_road",
              "windthrow_prct" = "proportion_tree_windthrown", 
              "windthrow_code" = "x_windthrow_code")

# Make just one 'distance from edge' variable
f$dist_from_edge <- ifelse(f$f_dist_lt40 > 0, f$f_dist_lt40, f$f_dist_gt40)
f$log_dist_from_edge <- log(f$dist_from_edge + 1)

# Next, say if it's in old, new, or edge of forest.
f <- f |> dplyr::mutate(f_dist_lt40 = round(f_dist_lt40, 0),
                        f_dist_gt40 = round(f_dist_gt40, 0),
                        age = dplyr::case_when((f_dist_lt40 == f_dist_gt40) ~ "on_edge",
                                         (f_dist_lt40 > f_dist_gt40) ~ "within_old",
                                         (f_dist_lt40 < f_dist_gt40) ~ "within_young"))

# Add a `den_status_binary` column
f <- f |> dplyr::mutate(den_status_binary = dplyr::case_when(grepl("No", den_status) ~ "Not Active",
                                                     den_status %in% c("Active in last denning season", "Currently active") ~ "Active",
                                                     den_status == "Obsolete" ~ "Obsolete",
                                                     den_status == "Unknown" ~ "Unknown",
                                                     TRUE ~ "Unknown"))

# If "Active recently (0-4 seasons)" is the very first data point, 
# change it to "Active". 
f <- f |>
  dplyr::arrange(den_id, date_inspected) |>
  dplyr::group_by(den_id) |>
  dplyr::mutate(cumulative_visit = cumsum(!is.na(den_id))) |>
  dplyr::mutate(den_status_binary = ifelse(cumulative_visit == 1 & den_status == "Active recently (0-4 seasons)",
                                           "Active",
                                           den_status_binary))

# Double check our categories
unique(f[,c("den_status", "den_status_binary")]) |> 
  dplyr::arrange(den_status_binary) |>
  knitr::kable()

# Add a column indicating N active and whether or not the den was 
# ever active
f <- f |> 
  dplyr::group_by(den_id) |>
  dplyr::mutate(active_n = sum(den_status_binary == "Active")) |>
  dplyr::mutate(ever_active_yn = active_n > 0)
```


```{r f_analysis prep, include = FALSE}
# Rename forestry columns to more consistent/easier to use names
f_analysis <- dplyr::rename(f_analysis,
              "nearest_tree_m" = "distance_nearest_tree_field",
              "f_prop_forest_60m" = "proportion_forested_field",
              "v_prop_forest_60m" = "proportion_forested",
              "f_dist_lt40" = "distance_less40yr_forest_field", 
              "v_dist_lt40" = "v_distance_less40yr_forest",
              "f_dist_gt40" = "distance_grtr40yr_forest_field", 
              "v_dist_gt40" = "v_distance_grtr40year_forest", 
              "f_dist_road" = "distance_nearest_road", 
              "v_dist_road" = "v_distance_nearest_road",
              "windthrow_prct" = "proportion_tree_windthrown", 
              "windthrow_code" = "x_windthrow_code")

# Next, make just one 'distance from edge' variable
f_analysis$dist_from_edge <- ifelse(f_analysis$f_dist_lt40 > 0, f_analysis$f_dist_lt40, f_analysis$f_dist_gt40)
f_analysis$log_dist_from_edge <- log(f_analysis$dist_from_edge + 1)

# Next, say if it's in old, new, or edge of forest.
f_analysis <- f_analysis |> dplyr::mutate(f_dist_lt40 = round(f_dist_lt40, 0),
                              f_dist_gt40 = round(f_dist_gt40, 0),
                              age = dplyr::case_when((f_dist_lt40 == f_dist_gt40) ~ "on_edge",
                                               (f_dist_lt40 > f_dist_gt40) ~ "within_old",
                                               (f_dist_lt40 < f_dist_gt40) ~ "within_young"))

# Add a `den_status_binary` column
f_analysis <- f_analysis |> dplyr::mutate(den_status_binary = dplyr::case_when(grepl("No", den_status) ~ "Not Active",
                                                     den_status %in% c("Active in last denning season", "Currently active") ~ "Active",
                                                     den_status == "Obsolete" ~ "Obsolete",
                                                     den_status == "Unknown" ~ "Unknown",
                                                     TRUE ~ "Unknown"))

# If "Active recently (0-4 seasons)" is the very first data point, 
# change it to "Active". 
f_analysis <- f_analysis |>
  dplyr::arrange(den_id, date_inspected_den) |>
  dplyr::group_by(den_id) |>
  dplyr::mutate(cumulative_visit = cumsum(!is.na(den_id))) |>
  dplyr::mutate(den_status_binary = ifelse(cumulative_visit == 1 & den_status == "Active recently (0-4 seasons)",
                                           "Active",
                                           den_status_binary))

# Add a column indicating N active and whether or not the den was 
# ever active
f_analysis <- f_analysis |> 
  dplyr::group_by(den_id) |>
  dplyr::mutate(active_n = sum(den_status_binary == "Active")) |>
  dplyr::mutate(ever_active_yn = active_n > 0)

# Merge spatial/static den data with analysis subset of field visits
f_analysis <- merge(dens, f_analysis, by = "den_id")

# Bin proportion forested data into groups (sort of ~young, old, medium, very old)
prop_1km$lt_3 <- rowSums(prop_1km[,c("age_class_1", "age_class_2")])
prop_1km$gt_3 <- rowSums(prop_1km[,6:12])
prop_1km$three_to_7 <- rowSums(prop_1km[,6:10])
prop_1km$gt_8 <- rowSums(prop_1km[,c("age_class_8", "age_class_9")])

# Merge landscape scale forestry metrics with the f_analysis dataset
# Merge % age class to `f_analysis`
f_analysis <- merge(f_analysis, prop_1km, by.x = "sample_id_forest", by.y = "sample_id")
f_analysis <- dplyr::select(f_analysis, -den_id.y, -year.y)
names(f_analysis)[grep("den_id.x", names(f_analysis))] <- "den_id"
names(f_analysis)[grep("year.x", names(f_analysis))] <- "year"

# Note the all.x = TRUE. If the den isn't in
# the road density df, the road density is 0.
f_analysis <- merge(f_analysis, road_density, 
                    by.x = "sample_id_forest", 
                    by.y = "sample_id", 
                    all.x = TRUE) # again, merging GIS forestry data for the year PRIOR to the den status year
f_analysis <- dplyr::select(f_analysis, -den_id.y, -year.y)
names(f_analysis)[grep("den_id.x", names(f_analysis))] <- "den_id"
names(f_analysis)[grep("year.x", names(f_analysis))] <- "year"

f_analysis$road_density_m2 <- ifelse(is.na(f_analysis$road_density_m2), 0, f_analysis$road_density_m2)

# We'll use the den year sample_id (rather than the forestry year sample id)
# as the default sample id
f_analysis$sample_id <- f_analysis$sample_id_den

# Subset to only columns we care about
# EDIT: this causes so many issues down the line with later wanting
# to examine a variable that didn't make the cut here. Maybe remove?
# f_analysis <- f_analysis |>
#   dplyr::select(sample_id, den_id, den_status, den_status_binary,
#                 sample_id_forest, sample_id_den,
#                 date_inspected_den, date_inspected_forest, year,
#                 region, latitude, longitude,
#                 struct_stage, age_class, canopy_closure,
#                 elevation_m, slope_pct, slope_aspect,
#                 bed_depth, bed_width, bed_length,
#                 hair_in_bed,
#                 forestry_treatment_desc,
#                 age_class, age_class_1:age_class_9,
#                 lt_3, gt_3, three_to_7, gt_8,
#                 f_prop_forest_60m,
#                 f_dist_lt40, f_dist_gt40,
#                 f_dist_from_edge, log_dist_from_edge,
#                 f_dist_road,
#                 windthrow_prct, windthrow_code,
#                 age_class_1:road_density_m2)
```

```{r f_full prep, include = FALSE}
f_full <- merge(dens, f, by = "den_id")
```

There are currently **`r length(unique(f$den_id))`** dens being tracked, and a total of **`r nrow(f)`** field visits completed to date (**`r Sys.Date()`**).

```{r den map, out.width='100%', fig.height=6.5, eval=require('leaflet'), echo = FALSE}
dens %>%
  st_transform(4326) %>%
  leaflet() %>% 
  addTiles() %>%
  setView(lng = -127.8, lat = 51.5, zoom = 6) %>%
  addCircleMarkers(layerId = ~den_id,
                   radius = 4,
                   color = "#c852ef",
                   stroke = FALSE,
                   fillOpacity = 0.8,
                   popup = ~htmltools::htmlEscape(den_id)) %>%
  addTiles("Jawg.Terrain", 
           options = providerTileOptions(accessToken = jawg_token),
           group = "Terrain") %>%
  addProviderTiles("Esri.WorldImagery",
                   group = "Satellite") %>%
  addLayersControl(baseGroups = c("Terrain", "Satellite"),
                   position = "topright") %>%
  addMeasure(primaryLengthUnit = "meters")
  
  
```

.footnote[*Use the menus on the top-right to change the basemap or perform measurements.*]

---

# Overall summary

```{r, dev.args=list(bg="transparent")}
f |> 
  dplyr::mutate(year = lubridate::year(date_inspected)) |>
  ggplot(aes(x = year)) +
  geom_bar() +
  scale_x_continuous(breaks = 2014:2024) +
  labs(x = "Year",
       y = "N field visits",
       title = "Number of field visits per year") +
  theme_minimal() 
```

---

# Overall summary

```{r, dev.args=list(bg="transparent")}
f |> 
  dplyr::mutate(year = lubridate::year(date_inspected)) |>
  dplyr::filter(grepl("Yes", monitored_by_camera)) |>
  ggplot(aes(x = year)) +
  geom_bar() +
  scale_x_continuous(limits = c(2014,2024.5), 
                     breaks = 2014:2024) +
  labs(x = "Year",
       y = "N deployed cameras",
       title = "Number of deployed cameras per year") +
  theme_minimal() 
```


---

# Overall summary

### Den Status - what have we got?

```{r, echo=FALSE}
knitr::kable(table(f$den_status), col.names = c("Den Status", "N"))
```

---

# Overall summary

```{r, dev.args=list(bg="transparent")}
f |> 
  dplyr::filter(den_status %in% c("Currently active", "Active in last denning season")) |>
  dplyr::mutate(year = lubridate::year(date_inspected)) |>
  ggplot(aes(x = year)) +
  geom_bar() +
  scale_x_continuous(breaks = 2014:2024) +
  labs(x = "Year",
       y = "N active dens",
       title = "Number of dens determined to be 'Active' per year") +
  theme_minimal() 
```

---

# Where are our dens?
### District

```{r, echo = FALSE}
knitr::kable(table(dens$district), col.names = c("District", "N"))
```

---

# Where are our dens?
### Region

```{r, fig.height = 5.5, dev.args=list(bg="transparent")}
dens |> 
  ggplot(aes(x = region)) +
  geom_bar() +
  labs(x = "Region",
       y = "N dens",
       title = "Number of dens in each region") +
  theme_minimal() 
```

---

# Where are our dens?
### District

```{r, fig.height = 5.5, dev.args=list(bg="transparent")}
dens |> 
  ggplot(aes(x = district)) +
  geom_bar() +
  labs(x = "District",
       y = "N dens",
       title = "Number of dens in each district") +
  theme_minimal() 
```

---
class: center, middle, inverse

# What does a den look like?

---

# What does a den look like?
### Den Tree Species

```{r, echo = FALSE}
knitr::kable(table(dens$den_tree_species), col.names = c("Den Tree Species", "N"))
```

---

# What does a den look like?
### Proportion by tree species

```{r, echo = FALSE}
trees <- table(dens$den_tree_species)
knitr::kable(round((trees/sum(trees))*100, 0), col.names = c("Den Tree Species", "%"))
```

---

# What does a den look like?
### Den Type

```{r, echo = FALSE}
knitr::kable(table(dens$den_type), col.names = c("Den Type", "N"))
```

---

# What does a den look like?
### DBH

```{r, fig.height = 5.5}
hist(dens$den_tree_dbh, main = "Histogram of Den Tree DBH", xlab = "DBH (cm)")
```

---

# What does a den look like?
### Chamber width, height, and length

```{r, fig.height = 5.5, dev.args=list(bg="transparent")}
dens |>
  sf::st_drop_geometry() |>
  dplyr::select(chamber_width, chamber_height, chamber_length) |>
  tidyr::pivot_longer(cols = 1:3,
                      names_to = "Measurement",
                      values_to = "cm") |>
  ggplot(aes(x = cm)) +
  geom_density(aes(color = Measurement,
                   fill = Measurement),
               alpha = 0.1) +
  scale_color_manual(values = c("#E69F00", "#009E73", "#CC79A7"),
                     name = "Measurement",
                     labels = c("Chamber height",
                                "Chamber length",
                                "Chamber width")) +
  scale_fill_manual(values = c("#E69F00", "#009E73", "#CC79A7"),
                    name = "Measurement",
                    labels = c("Chamber height",
                               "Chamber length",
                               "Chamber width")) +
  labs(x = "Measurement (cm)",
       y = "Density") +
  theme_minimal()
```

---

# What does a den look like?
### Dens with Bed Cups during each field visit (N)

```{r}
knitr::kable(table(f$bedding_cup_present), col.names = c("Bedding Cup Present?", "N"))
```

---

# What does a den look like?
### Dens with Bed Cups during each field visit (%)

```{r}
cups <- table(f$bedding_cup_present)
knitr::kable(round(cups/sum(cups)*100, 0), col.names = c("Bedding Cup Present?", "%"))
```

---

# What does a den look like?
### What proporion of dens have certain bedding materials?

```{r}
bedding <- f[,c("den_id", "bedding_material_details")]
bedding$salal_yn <- grepl("salal", bedding$bedding_material_details, ignore.case = TRUE)
bedding$fern_yn <- grepl("fern", bedding$bedding_material_details, ignore.case = TRUE)
bedding$moss_yn <- grepl("moss", bedding$bedding_material_details, ignore.case = TRUE)
bedding$cedarhemlock_yn <- grepl("cedar|hemlock", bedding$bedding_material_details, ignore.case = TRUE)
bedding$needles_yn <- grepl("needles", bedding$bedding_material_details, ignore.case = TRUE)
bedding$twigsbranches_yn <- grepl("twig|twigs|branch|branches", bedding$bedding_material_details, ignore.case = TRUE)
bedding$duff_yn <- grepl("duff", bedding$bedding_material_details, ignore.case = TRUE)
bedding$scrapings_yn <- grepl("scraping|scrapings", bedding$bedding_material_details, ignore.case = TRUE)
bedding$nomaterial_yn <- grepl("(?<=No|no)(.*)(?=material)", bedding$bedding_material_details, ignore.case = TRUE, perl = TRUE)

bedding2 <- bedding |> 
    dplyr::select(-bedding_material_details) |> 
    dplyr:: group_by(den_id) |> 
    summarise_all(sum) |> 
    dplyr::select(-den_id)

bedding2[bedding2 != 0] <- 1

bedding2 <- data.frame(material = c("Salal", "Ferns", "Moss", "Cedar/Hemlock",
                                    "Needles", "Twigs/Branches", "Duff", "Scrapings", 
                                    "No imported material"),
                       n_dens = colSums(bedding2))
rownames(bedding2) <- NULL
bedding2$prct <- paste0(round(bedding2$n_dens / length(unique(bedding$den_id)), 2) * 100, "%")

knitr::kable(bedding2, col.names = c("Material", "N dens", "% dens"))
```

---

# What does a den look like?
### Hair in Den during each field visit (N)

```{r}
knitr::kable(table(f$hair_in_bed), col.names = c("Hair in Den?", "N"))
```

---

# What does a den look like?
### Hair in Den during each field visit (%)

```{r}
hair <- table(f$hair_in_bed)
knitr::kable(round(hair/sum(hair)*100, 0), col.names = c("Hair in Den?", "%"))
```

---

# What does a den look like?
### Hair on Entrance during each field visit (N)

```{r}
knitr::kable(table(f$hair_on_entrance), col.names = c("Hair on Entrance?", "N"))
```

---

# What does a den look like?
### Hair on Entrance during each field visit (%)

```{r}
hair <- table(f$hair_on_entrance)
knitr::kable(round(hair/sum(hair)*100, 0), col.names = c("Hair on Entrance?", "%"))
```

---

# What does a den look like?
### Age Class

```{r, echo = FALSE}
knitr::kable(table(dens$age_class), col.names = c("Age Class", "N"))
```

---

# What does a den look like?
### Den State (initial visit)

```{r, echo = FALSE}
knitr::kable(table(dens$den_state), col.names = c("Den State", "N"))
```

---

# What's the geography like?
### Elevation

```{r}
hist(dens$elevation_m, main = "Histogram of den elevations", xlab = "Elevation (m)")
```

--- 

# What's the geography like?
### Slope grade (%)

```{r}
hist(dens$slope_pct, main = "Histogram of slope grades", xlab = "Slope (%)")
```

--- 

# What's the geography like?
### Slope aspect

```{r}
hist(dens$slope_aspect, main = "Histogram of slope aspects", xlab = "Slope aspect (degrees)",
     xlim = range(0, 360), breaks = seq(0, 360, 45))
```

---
class: center, middle, inverse

# Den Status

## Rates of Re-Use

---

### Den Status - what have we got?

```{r, echo=FALSE}
knitr::kable(table(f$den_status), col.names = c("Den Status", "N"))
```

---
class: center

### "Active"

Dens with the highlighted status were considered "confirmed active" within the last season.

.footnote[\* If the first datapoint in the timeseries was `Active recently (0-4 seasons)`, we counted it as `Active` (*N* = `r nrow(f[f$den_status == "Active recently (0-4 seasons)" & f$den_status_binary == "Active", ])`).]

```{r, echo=FALSE}
f |>
  dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                    "Active recently (0-4 seasons)*",
                                    den_status)) |>
  dplyr::pull(den_status) |>
  table() |>
  knitr::kable(col.names = c("Den Status", "N")) |> 
  kableExtra::kable_styling() |> 
  kableExtra::row_spec(c(1, 3), bold = TRUE, background = "#b58900") |>
  kableExtra::row_spec(c(2), bold = TRUE, background = "#e1c056") |>
  kableExtra::kable_styling(font_size = 14)
```

---
class: center

### "Non-Active"

Dens with the highlighted status were considered "confirmed *not* active" within the last season.

.footnote[\* If the first datapoint in the timeseries was `Active recently (0-4 seasons)`, we counted it as `Active` (*N* = `r nrow(f[f$den_status == "Active recently (0-4 seasons)" & f$den_status_binary == "Active", ])`).]

```{r, echo=FALSE}
f |>
  dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                    "Active recently (0-4 seasons)*",
                                    den_status)) |>
  dplyr::pull(den_status) |>
  table() |>
  knitr::kable(col.names = c("Den Status", "N")) |> 
  kableExtra::kable_styling() |> 
  #kableExtra::row_spec(c(1:4), bold = FALSE, background = "#b58900") |>
  kableExtra::row_spec(c(4:7), bold = TRUE, background = "#93a1a1") |>
  kableExtra::kable_styling(font_size = 14)
```

---
class: center

### "Unknown/Obsolete"

Dens with the highlighted status were excluded from den status assessments.


.footnote[\* If the first datapoint in the timeseries was `Active recently (0-4 seasons)`, we counted it as `Active` (*N* = `r nrow(f[f$den_status == "Active recently (0-4 seasons)" & f$den_status_binary == "Active", ])`).]

```{r, echo=FALSE}
f |>
  dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                    "Active recently (0-4 seasons)*",
                                    den_status)) |>
  dplyr::pull(den_status) |>
  table() |>
  knitr::kable(col.names = c("Den Status", "N")) |> 
  kableExtra::kable_styling() |> 
  #kableExtra::row_spec(c(1:4), bold = FALSE, background = "#b58900") |>
  #kableExtra::row_spec(c(5:14), bold = FALSE, background = "#93a1a1") |>
  kableExtra::row_spec(c(2), bold = TRUE, background = "#e1c056") |>
  kableExtra::row_spec(c(8:9), bold = TRUE, color = "white", background = "#cb4b16") |>
  kableExtra::kable_styling(font_size = 14)
```

---
class: center

### All statuses

Dens with the highlighted status were excluded from den status assessments.

.footnote[\* If the first datapoint in the timeseries was `Active recently (0-4 seasons)`, we counted it as `Active` (*N* = `r nrow(f[f$den_status == "Active recently (0-4 seasons)" & f$den_status_binary == "Active", ])`).]

```{r, echo=FALSE}
f |>
  dplyr::mutate(den_status = ifelse(den_status == "Active recently (0-4 seasons)",
                                    "Active recently (0-4 seasons)*",
                                    den_status)) |>
  dplyr::pull(den_status) |>
  table() |>
  knitr::kable(col.names = c("Den Status", "N")) |> 
  kableExtra::kable_styling() |> 
  kableExtra::row_spec(c(1, 3), bold = FALSE, background = "#b58900") |>
  kableExtra::row_spec(c(2), bold = TRUE, background = "#e1c056") |>
  kableExtra::row_spec(c(4:7), bold = FALSE, background = "#93a1a1") |>
  kableExtra::row_spec(c(8:9), bold = TRUE, color = "white", background = "#cb4b16") |>
  kableExtra::kable_styling(font_size = 14)
```
---

# Rates of re-use

First need to categorize dens into `Active`, `Not Active`, or `Unknown`.
Based on the highlighted rows in the tables of the previous slides, we have:

```{r den_status_binary, echo = FALSE}
# Add a `den_status_binary` column
f <- f |> dplyr::mutate(den_status_binary = dplyr::case_when(grepl("No", den_status) ~ "Not Active",
                                                     den_status %in% c("Active in last denning season", "Currently active") ~ "Active",
                                                     den_status == "Obsolete" ~ "Obsolete",
                                                     den_status == "Unknown" ~ "Unknown",
                                                     TRUE ~ "Unknown"))

# Double check our categories
unique(f[,c("den_status", "den_status_binary")]) |> 
  dplyr::arrange(den_status_binary) |>
  knitr::kable()
```


---

# Rates of re-use

First need to categorize dens into `Active`, `Not Active`, or `Unknown`.
Based on the highlighted rows in the tables of the previous slides, we have:

```{r}
plyr::count(f$den_status_binary) |>
  knitr::kable(col.names = c("Den Status", "N"))
```

Total number of visits = **`r nrow(f)`**

---

# Rates of re-use

First need to categorize dens into `Active`, `Not Active`, or `Unknown`.
Based on the highlighted rows in the tables of the previous slides, we have:

```{r}
plyr::count(f$den_status_binary) |>
  dplyr::mutate(freq = round(freq/nrow(f) * 100)) |>
  knitr::kable(col.names = c("Den Status", "%"))
```

Total number of visits = **`r nrow(f)`**

---

# Rates of re-use

For now, I'm counting `Unknown`s the same as `Not Active`.

This is a quick and dirty assignment of 're-use' - it doesn't take into account if there's been a large temporal gap (e.g., years) between visits.

But, essentially, if the status was `Active` for two records in a row, it's counted as *re-used*.

```{r}
# Arrange table by den_id and date_inspected
f <- f[order(f$den_id, f$date_inspected),]
# Add in a cumulative visit col by each den - i.e. the Nth field visit to the given den
f <- f |>
  dplyr::group_by(den_id) |>    
  dplyr::mutate(cumulative_visit = cumsum(!is.na(den_id)))
# Create `reuse_yn` col - if den was revisited at all
f <- f |> 
    dplyr::group_by(den_id) |>
    dplyr::mutate(count_active = sum(den_status_binary == "Active"),
                  reuse_yn = count_active > 1)
# Create `consecutiveuse_yn` col - if den visited two years in a row
f <- f |> 
  dplyr::group_by(den_id) |>
  dplyr::mutate(year_diff = lubridate::year(date_inspected) - dplyr::lag(lubridate::year(date_inspected))) |> # so cumulative visits only count if they're one year apart (e.g., a visit in 2016 and then in 2020 is NOT a cumulative visit)
  dplyr::mutate(consecutiveuse_yn = ifelse((cumulative_visit == 1 & year_diff == 1),
                                  # If it's the first visit to the den, set `reuse_yn` == NA
                                  NA, 
                                  # Else if it's NOT the first visit, and the previous record says "Active", set `reuse_yn` == TRUE
                                  (dplyr::lag(den_status_binary) == "Active" & den_status_binary == "Active"))
                )
```

---

#### Rates of re-use

```{r, echo = FALSE}
f[,c("den_id", "sample_id", "date_inspected", "cumulative_visit", "den_status_binary", "reuse_yn", "consecutiveuse_yn")] |> 
  DT::datatable(options = list(
    pageLength = 8,
    scrollX = FALSE,
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '50%'});",
      "}"
      )
    )) |>
  DT::formatStyle(columns = c(1:6), fontSize = "50%") |>
  DT::formatStyle(columns = c(1:6), width = c("5%"))
```

---

# Rates of re-use

#### Number of dens never used

```{r}
f |> 
  dplyr::group_by(den_id) |>
  dplyr::summarise(count_active = mean(count_active)) |>
  dplyr::group_by(count_active) |>
  dplyr::summarise(n = dplyr::n()) |>
  knitr::kable(col.names = c("Number of times den was Active", "N dens"))
```

---

# Rates of re-use

#### Number of dens never used

```{r}
f |> 
  dplyr::group_by(den_id) |>
  dplyr::summarise(count_active = mean(count_active)) |>
  dplyr::group_by(count_active) |>
  dplyr::summarise(n = dplyr::n()) |>
  dplyr::mutate(prct = round(n/sum(n) * 100)) |>
  dplyr::select(count_active, prct) |>
  knitr::kable(col.names = c("Number of times den was Active", "%"))
```


---

# Rates of re-use

#### Number of consecutive re-uses

Den was re-used two years in a row

.footnote[*Note that `NA` signifies the first visit to a den - we don't know if `reuse_yn == TRUE` or `FALSE` bc it's the first visit*]

```{r}
knitr::kable(plyr::count(f$consecutiveuse_yn), col.names = c("Re-Used Consecutively (T/F)", "N"))
```

---

# Rates of re-use

#### Percent of consecutive use

Den was re-used two years in a row

.footnote[*Note that `NA` signifies the first visit to a den - we don't know if `reuse_yn == TRUE` or `FALSE` bc it's the first visit*]

```{r}
knitr::kable(plyr::count(f$consecutiveuse_yn) |> dplyr::mutate(freq = round(freq/nrow(f) * 100)), col.names = c("Re-Used Consecutively (T/F)", "%"))
```


---

# Rates of re-use

### A few example dens...

---

# Rates of re-use

### ADA_EveRiver_1

Was never active in the first place.

```{r, echo = FALSE}
f[f$den_id == "ADA_EveRiver_1", c("den_id", "sample_id", "date_inspected", "cumulative_visit", "den_status_binary", "reuse_yn")] |>
  knitr::kable() |>
  kableExtra::kable_styling(font_size = 14)
```

---

# Rates of re-use

### COU_CousCreek_2

Active more than once, but not two years in a row. 

```{r, echo = FALSE}
f[f$den_id == "COU_CousCreek_2", c("den_id", "sample_id", "date_inspected", "cumulative_visit", "den_status_binary", "reuse_yn")] |>
  knitr::kable() |>
  kableExtra::kable_styling(font_size = 14)
```

---

# Rates of re-use

### TSI_MountRussell_2

Was active, but then turned `Obsolete`.

```{r, echo = FALSE}
f[f$den_id == "TSI_MountRussell_2", c("den_id", "sample_id", "date_inspected", "cumulative_visit", "den_status_binary", "reuse_yn")] |>
  knitr::kable() |>
  kableExtra::kable_styling(font_size = 14)
```

---

# Rates of re-use

### SAN_RonningCreek_2

Active for two years in a row!

```{r, echo = FALSE}
f[f$den_id == "SAN_RonningCreek_2", c("den_id", "sample_id", "date_inspected", "cumulative_visit", "den_status_binary", "reuse_yn")] |>
  knitr::kable() |>
  kableExtra::kable_styling(font_size = 14)
```


---
class: center, middle, inverse

# Forestry summary data

---

### Canopy closure

Note this value was not updated past the first field visit.

```{r}
hist(dens$canopy_closure, main = "Histogram of canopy closure", xlab = "Canopy closure (%)", xlim = range(0, 100))
```

---

### Patch Type

.footnote[Note that not all dens have patch size categorized (N = `r nrow(f[!is.na(f$forestry_treatment_desc), ])` out of `r nrow(f)`).]

```{r fig.height = 5.5}
ggplot(f[!is.na(f$forestry_treatment_desc),]) + 
  geom_bar(aes(x = forestry_treatment_desc,
               fill = forestry_treatment_desc)) +
  scale_fill_bright(name = "Patch Type") +
  scale_x_discrete(labels = c("CF", "Edge", "LRP", "MRP", "NR;NS", "NR;SI", "Other", "NA")) +
  labs(x = "Patch Type",
       y = "Count") +
  theme_minimal() #+ 
  #theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))
```

---

### Proportion forested within 60m

Note this includes all field visits, including dens with repeated visits.

```{r}
summary(f$f_prop_forest_60m)
```

```{r, fig.height=5}
hist(f$f_prop_forest_60m, main = "Histogram of Proportion Forested", xlab = "Proportion Forested within 60m (%)")
```

---

### Distance to <40 yo forest

Note this includes all field visits, including dens with repeated visits.

```{r}
summary(f$f_dist_lt40)
```

```{r, fig.height=5}
hist(f$f_dist_lt40, main = "Histogram of Distance to <40yo Forest", xlab = "Distance to <40 yo forest (m)")
```

---

### Distance to <40 yo forest: Zoomed in to 0-500m

Majority of dens are <100 meters from <40 yo forest (cutblock edge).

```{r}
summary(f$f_dist_lt40)
```

```{r, fig.height=5}
hist(f$f_dist_lt40, main = "Histogram of Distance to <40yo Forest", xlab = "Distance to <40 yo forest (m)", xlim = range(0, 500), breaks = 100)
```

---

### Distance to >40 yo forest

Note this includes all field visits, including dens with repeated visits.

```{r}
summary(f$f_dist_gt40)
```

```{r, fig.height=5}
hist(f$f_dist_gt40, main = "Histogram of Distance to >40yo Forest", xlab = "Distance to >40 yo forest (m)")
```

---

### Distance to >40 yo forest: Zoomed in to 0-50m

Vast majority of dens are already *within* >40 yo forest.

```{r}
summary(f$f_dist_gt40)
```

```{r, fig.height=5}
hist(f$f_dist_gt40, main = "Histogram of Distance to >40yo Forest", xlab = "Distance to >40 yo forest (m)", xlim = c(0, 50), breaks = 100)
```


---

### Distance to nearest road

Note this includes all field visits, including dens with repeated visits.

```{r}
summary(f$f_dist_road)
```

```{r, fig.height=5}
hist(f$f_dist_road, main = "Histogram of Distance to Nearest Road", xlab = "Distance to nearest road (m)")
```

---

### Distance to nearest road: Zoomed in to 0-500m

Distribution is skewed towards 0, but less so than distance to cutblock edge/mature growth.

```{r}
summary(f$f_dist_road)
```

```{r, fig.height=5}
hist(f$f_dist_road, main = "Histogram of Distance to Nearest Road", xlab = "Distance to nearest road (m)", xlim = c(0, 500), breaks = 100)
```


---

### Proportion age class within 1.5 km

Note this includes all field visits, including dens with repeated visits

```{r}
# The age class cols are already percentages for each year. So, just
# take the mean percentage of each age class across all years
round(colSums(prop_1km[,4:12]) / nrow(prop_1km)) |>
  knitr::kable(col.names = c("Stand Age Class", "Percentage"))
```

---

### Proportion age class within 1.5 km

Note this includes all field visits, including dens with repeated visits

```{r, echo = FALSE, fig.width = 10, dev.args=list(bg="transparent")}
prop_1km |>  
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 4:12, names_to = "age_class", names_prefix = "age_class_") |>
  dplyr::mutate(age_class = factor(age_class, levels = c(1:9))) |>
  # Then summarize the mean % age class by year 
  dplyr::group_by(year, age_class) |> 
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  scale_fill_light(reverse = TRUE) +
  theme_minimal()
```

---

### Proportion age class within 1.5 km

Note this includes all field visits, including dens with repeated visits

```{r, echo = FALSE, fig.width = 10, dev.args=list(bg="transparent")}
prop_1km |>  
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 4:12, names_to = "age_class", names_prefix = "age_class_") |>
  # Condense age class for each den visit into either ">= 3" or "< 3"
  dplyr::mutate(age_class = ifelse(grepl("1|2", age_class), "Less than 3", "Greater or equal to 3")) |>
  dplyr::mutate(age_class = factor(age_class, levels = c("Less than 3", "Greater or equal to 3"))) |> # Flip plotting order so it stays lined up with previous graph
  dplyr::group_by(sample_id, year, age_class) |>
  dplyr::summarise(value = sum(value)) |>
  # Then summarize the mean % age class by year
  dplyr::group_by(year, age_class) |>
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  scale_fill_light(reverse = TRUE) +
  theme_minimal()
```

---

### Proportion age class within 1.5 km

Note this includes all field visits, including dens with repeated visits

```{r, echo = FALSE, fig.width = 10, dev.args=list(bg="transparent")}
prop_1km |>  
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 4:12, names_to = "age_class", names_prefix = "age_class_") |>
  dplyr::mutate(age_class = as.numeric(age_class)) |>
  # Condense age class for each den visit into either ">= 3" or "< 3"
  dplyr::mutate(age_class = dplyr::case_when(age_class < 3 ~ "Less than 3",
                                             age_class >= 8 ~ "Older than 7",
                                             TRUE ~ "3 to 7")) |>
  dplyr::mutate(age_class = factor(age_class, levels = c("Less than 3", "3 to 7", "Older than 7"))) |>
  dplyr::group_by(sample_id, year, age_class) |>
  dplyr::summarise(value = sum(value)) |>
  # Then summarize the mean % age class by year
  dplyr::group_by(year, age_class) |>
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  scale_fill_light(reverse = TRUE) +
  theme_minimal()
```

---

### Road density within 1.5 km

Note this includes all field visits, including dens with repeated visits.

```{r}
summary(road_density$road_density_m2)
```

```{r, fig.height=5}
hist(road_density$road_density_m2, main = "Histogram of Road Density", xlab = "Road Density within 1.5km radius")
```

---

### Road density within 1.5 km

It doesn't change much through time... (this will be a theme)

```{r, echo = FALSE, fig.width = 7, dev.args=list(bg="transparent")}
road_density |>
  ggplot(aes(x = year, y = road_density_m2, color = den_id)) +
  geom_line() +
  geom_point() +
  labs(title = "Road density for each den through time") +
  theme_minimal() +
  theme(legend.position = "none")
```

---
class: center, middle, inverse

# Forestry vs. Den Status

---

# Forestry vs. Den Status

Now, we need to do a bit of data wrangling. In theory, the den status of **the current year** is influenced by the forestry data **from the year before**. So, we match the den status with last year's forestry data from our field visits. In doing so, this cuts our dataset own to `r nrow(f_analysis)` records. 

With the exception of age class and canopy closure, all subsequent plots show den status of year *N* versus forestry data from year *N - 1*. Age class and canopy closure were only measured once in the study (at the first den visit).

---

## Den Status vs Age Class

```{r}
chisq <- f_full |>
  sf::st_drop_geometry() |>
  dplyr::mutate(den_status_binary = dplyr::case_when(grepl("No", den_status) ~ "Not Active",
                                                     den_status %in% c("Active in last denning season", "Currently active") ~ "Active",
                                                     den_status == "Obsolete" ~ "Obsolete",
                                                     den_status == "Unknown" ~ "Unknown",
                                                     TRUE ~ "Unknown")) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::group_by(age_class, den_status_binary) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = age_class,
                     values_from = n) |>
  dplyr::mutate(den_status_binary = dplyr::if_else(!is.na(den_status_binary), den_status_binary, "NA")) |>
  tibble::column_to_rownames(var = "den_status_binary") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

## Den Status vs Canopy Closure

```{r fig.height = 5.5, echo = FALSE, dev.args=list(bg="transparent")}
#hrbrthemes::import_plex_sans()

ggplot(f_full, aes(x = den_status_binary,
                       y = canopy_closure,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) + 
  labs(x = "Den Status",
       y = "Canopy Closure (%)")
```

---

## Den Status vs Patch Type

```{r}
chisq <- f_analysis |>
  sf::st_drop_geometry() |>
  dplyr::filter(!is.na(forestry_treatment_desc)) |>
  dplyr::group_by(forestry_treatment_desc, den_status_binary) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = den_status_binary,
                     values_from = n) |>
  tibble::column_to_rownames(var = "forestry_treatment_desc") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

## Den Status vs Proportion Forested within 60m

```{r fig.height = 5.5, echo = FALSE, dev.args=list(bg="transparent")}
#hrbrthemes::import_plex_sans()

ggplot(f_analysis, aes(x = den_status_binary,
                       y = f_prop_forest_60m,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) + 
  labs(x = "Den Status",
       y = "Proportion Forested within 60m (%)")
```


---

## Den Status vs Distance to <40 yo Forest

```{r, echo = FALSE, dev.args=list(bg="transparent")}
ggplot(f_analysis, aes(x = den_status_binary, 
                       y = f_dist_lt40,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  scale_y_log10() +
  annotation_logticks(side = "l") +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "LOG Distance to <40 yo forest (m)")
```


---

## Den Status vs Distance to >40 yo Forest

```{r, echo = FALSE, dev.args=list(bg="transparent")}
ggplot(f_analysis, aes(x = den_status_binary, 
                       y = f_dist_gt40, 
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  scale_y_log10() +
  annotation_logticks(side = "l") +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "LOG Distance to >40 yo forest (m)")
```

---

## Den Status vs Distance to >40 yo Forest

What are those 6 data points where distance to mature forest is >30 meters? 

Turns out it's all from 3 distinct dens:

```{r}
y <- f_analysis[f_analysis$f_dist_gt40 > 30 & f_analysis$den_status_binary == "Active",]

y[,c("den_id", "sample_id", "landscape_unit", "x_den_data_source", "struct_stage", "age_class", "canopy_closure", "den_type", "den_tree_species", "den_tree_dbh", "tree_appearance_code", "forestry_treatment_desc", "f_prop_forest_60m", "f_dist_lt40", "f_dist_gt40", "f_dist_road", "windthrow_code", "lt_3", "three_to_7", "gt_8", "road_density_m2")] |> 
  DT::datatable(options = list(
    pageLength = 8,
    scrollX = TRUE,
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '50%'});",
      "}"
      )
    )) |>
  DT::formatStyle(columns = c(1:6), fontSize = "50%") |>
  DT::formatStyle(columns = c(1:6), width = c("5%"))
```

---

## Den Status vs Distance to Nearest Road

```{r, echo = FALSE, dev.args=list(bg="transparent")}
ggplot(f_analysis, aes(x = den_status_binary, 
                       y = f_dist_road,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  scale_y_log10() +
  annotation_logticks(side = "l") +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "LOG Distance to nearest road")
```

---

## Den Status vs Proportion Old Growth

'Old growth' being % coverage of age class 8 or 9 within 1.5km of the den.

```{r, echo = FALSE, dev.args=list(bg="transparent")}
ggplot(f_analysis, aes(x = den_status_binary, 
                       y = gt_8,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "Old Growth within 1.5km (%)")
```

---

## Den Status vs Distance to New Growth

'New growth' being % coverage of age class 1 or 2 within 1.5km of the den.

```{r, echo = FALSE, dev.args=list(bg="transparent")}
ggplot(f_analysis, aes(x = den_status_binary, 
                       y = lt_3,
                       color = den_status_binary)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("Active", "Not Active")),
                        map_signif_level = TRUE) +
  #hrbrthemes::theme_ipsum_ps(axis_title_just = "mc") +
  hrbrthemes::scale_color_ipsum() +
  scale_y_continuous(limits = c(0,100)) +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) +
  labs(x = "Den Status",
       y = "New Growth within 1.5km (%)")
```


---
class: center, middle, inverse

# How well are we sampling the landscape?

---

# How well are we sampling the landscape?

The next set of slides will compare points randomly sampled across the landscape versus our dens. Compared to just randomly dropping pins on a map of Vancouver Island and Haida Gwaii, how well are we sampling the landscape with our sample of dens?

```{r pseudo dens setup, include = FALSE}
# pseudo_dens = randomly sampled points on the landscape
# to compare to our actual sampled dens
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(pseudo_dens))

# First, for the pseudo den data, we're going to make
# the same assumption as for the real data - this year's
# den status needs to be paired with last year's forestry.
# Add 1 from the pseudo data `year` so that the 
# data runs from 2019-2023, rather than 2020-2024, 
# because then it will line up with our real data (which
# only runs until 2023.)
pseudo_dens$year <- pseudo_dens$year + 1

# Add latitude, longitude cols to data
pseudo_dens <- cbind(pseudo_dens, st_coordinates(pseudo_dens))
names(pseudo_dens)[grep("X", names(pseudo_dens))] <- "longitude"
names(pseudo_dens)[grep("Y", names(pseudo_dens))] <- "latitude"

# Assign either VI or HG to data, to examine by island
pseudo_dens$region <- ifelse(pseudo_dens$latitude > 800000, "HG", "VI")

##### Assign random den status #####

# Randomly assign a den_status to the pseudo_data, following
# similar proportions as the actual data

# Pull the % distribution of den statuses from the actual
# data, then round to the nearest hundreth. We'll use those
# percentages to simulate den status in the pseudo data.
status_freq <- round(prop.table(table(f_analysis$den_status)), 2)
status_freq

# Generate random den status for our pseudo dens
pseudo_dens$den_status <- sample(names(status_freq), 
                                 nrow(pseudo_dens), 
                                 replace = TRUE, 
                                 prob = status_freq)

# Check that frequencies line up
prop.table(table(pseudo_dens$den_status))

# Make den status a factor
pseudo_dens$den_status <- factor(x = pseudo_dens$den_status,
                                 levels = c("Currently active", #x
                                            "Active in last denning season", #x
                                            "Active recently (0-4 seasons)", #x
                                            "Not active in last season, but recent use (1-4 seasons)", #x
                                            "Not active in last season, no recent use (>4 seasons)", #x
                                            "No recent evidence of use (>4 seasons)", #x
                                            "Not active in last season", #x
                                            "Obsolete", #x
                                            "Unknown")) #x

# Bin into binary categories
pseudo_dens <- pseudo_dens |> 
  dplyr::mutate(den_status_binary = dplyr::case_when(grepl("^No", den_status) ~ "Not active",
                                                     den_status == "Obsolete" ~ "Obsolete",
                                                     den_status == "Unknown" ~ "Unknown",
                                                     TRUE ~ "Active"))

# Pull our parks shapefiles
parks1 <- withr::with_dir(rprojroot::find_root('_targets.R'),
                          tar_read(hg_vi_tantalis_parks))
parks2 <- withr::with_dir(rprojroot::find_root('_targets.R'),
                          tar_read(hg_vi_tantalis_cons_areas))
parks3 <- withr::with_dir(rprojroot::find_root('_targets.R'),
                          tar_read(hg_vi_federal_parks))

names(parks2)[1] <- "PROTECTED_LANDS_NAME"
parks2$PROTECTED_LANDS_DESIGNATION <- "CONSERVANCY AREA"

names(parks3)[2] <- "PROTECTED_LANDS_NAME"
parks3$PROTECTED_LANDS_DESIGNATION <- "FEDERAL PARK"

parks <- dplyr::bind_rows(parks1, parks2, parks3)
parks <- st_as_sf(parks, wkt = "WKT_GEOM")
st_crs(parks) <- 3005
names(parks)[5] <- "geometry" # rename geometry column
st_geometry(parks) <- "geometry"
names(parks) <- tolower(names(parks))

rm(parks1, parks2, parks3)

# Intersect parks with dens/pseudo_dens, so we know how
# many pseudo dens were generated inside park lands
pseudo_dens$in_park <- FALSE
pseudo_dens[["in_park"]][unlist(st_intersects(parks, pseudo_dens))] <- TRUE

dens$in_park <- FALSE
dens[["in_park"]][unlist(st_intersects(parks, dens))] <- TRUE

# Merge dens$in_park to f_analysis
f_analysis <- merge(f_analysis, sf::st_drop_geometry(dens[,c("den_id", "in_park")]))

# And finally pull a shapefile of our study area
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(study_area))

##### Pull verification data #####
# Then pull our verification data
# Even though we've manually verified the den data to 
# be the best it can be, we're still going to compare
# just the autogenerated GIS forestry data for both
# groups, to ensure it's an apples-to-apples 
# comparison.
fv <- withr::with_dir(rprojroot::find_root('_targets.R'),
                            tar_read(forestry_verifications_full)) # read data verification results
pfv <- withr::with_dir(rprojroot::find_root('_targets.R'), 
                       tar_read(pseudo_forestry_verifications_full)) # pseudo data verification results

# Merge verification data to the spatial data
f_analysis <- merge(f_analysis, fv, by.x = "sample_id_forest", by.y = "sample_id") # again, merging GIS forestry data for the year PRIOR to the den status year
pseudo_dens <- merge(pseudo_dens, pfv, by = "sample_id")


##### Pull DEM data #####
# For each pseudo den, we have elevation, slope (%),
# and slope aspect, extracted from the BC CDED 30m data.
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(pseudo_dens_dem))
pseudo_dens_dem <- unique(pseudo_dens_dem)

pseudo_dens <- merge(pseudo_dens, pseudo_dens_dem)

rm(pseudo_dens_dem)

# And also clean the DEM data fields in the real data
f_analysis[["elevation_m"]][which(f_analysis$elevation_m == 999)] <- NA
f_analysis[["slope_pct"]][which(f_analysis$slope_pct > 200)] <- NA
f_analysis[["slope_aspect"]][which(f_analysis$slope_aspect > 360)] <- NA

##### Pull age class data #####
# For each pseudo den, we have the 2023 VRI age class.
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(pseudo_dens_age_class))
pseudo_dens_age_class <- sf::st_drop_geometry(pseudo_dens_age_class)

pseudo_dens <- merge(pseudo_dens, pseudo_dens_age_class, all.x = TRUE)

rm(pseudo_dens_age_class)

# And also clean up the age class field in the real data
# This will produce some NAs
pseudo_dens$proj_age_class_cd_1 <- as.numeric(pseudo_dens$proj_age_class_cd_1)
f_analysis$proj_age_class_cd_1 <- as.numeric(substring(f_analysis$age_class, 1, 1))



##### % age class #####
# already did this for f_analysis in one of the first chunks
pseudo_prct <- withr::with_dir(rprojroot::find_root('_targets.R'),
                            tar_read(pseudo_prct_age_class_1.5km))

# Bin the data into groups (sort of ~young, old, medium, very old)
pseudo_prct$lt_3 <- rowSums(pseudo_prct[,c("age_class_1", "age_class_2")])
pseudo_prct$gt_3 <- rowSums(pseudo_prct[,6:12])
pseudo_prct$three_to_7 <- rowSums(pseudo_prct[,6:10])
pseudo_prct$gt_8 <- rowSums(pseudo_prct[,c("age_class_8", "age_class_9")])

# Merge with den status - so we can look at percent of each
# age class with activity status
pseudo_dens <- merge(pseudo_dens, pseudo_prct, by = "sample_id")
pseudo_dens <- dplyr::select(pseudo_dens, -den_id.y, -year.y)
names(pseudo_dens)[grep("den_id.x", names(pseudo_dens))] <- "den_id"
names(pseudo_dens)[grep("year.x", names(pseudo_dens))] <- "year"


##### Road density #####
# `road_density` already loaded in the first chunk
withr::with_dir(rprojroot::find_root('_targets.R'), tar_load(pseudo_road_density))

pseudo_road_density <- pseudo_road_density[,c("sample_id", "road_density_m2")]

# Note the all.x = TRUE. If the den isn't in
# the road density df_analysis, the road density is 0.
pseudo_dens <- merge(pseudo_dens, pseudo_road_density, by = "sample_id", all.x = TRUE)
pseudo_dens$road_density_m2 <- ifelse(is.na(pseudo_dens$road_density_m2), 0, pseudo_dens$road_density_m2)

##### Merge datasets #####
pseudo_dens$type <- "Pseudo"
f_analysis$type <- "Real"

full <- dplyr::bind_rows(pseudo_dens, f_analysis)

# We'll use the den year sample_id (rather than the forestry year sample id)
# as the default sample id
full$sample_id <- ifelse(is.na(full$sample_id), full$sample_id_den, full$sample_id)

# Subset to only columns we care about + full observations
full <- full |> 
  dplyr::select(sample_id, den_id, type, year,
                den_status, den_status_binary,
                region, latitude, longitude, in_park,
                elevation_m, slope_pct, slope_aspect,
                proj_age_class_cd_1,
                prop_forest_60m, dist_lt40, dist_gt40, dist_road,
                age_class_1:road_density_m2)

# Filter to only 2019:2023
full <- full[which(full$year %in% c(2019:2024)), ]

#full <- na.omit(full) # this eliminates a lot of dens with incomplete DEM (slope, elevation, etc.) data

# Rename park variable so it's easier to tell what it is on plots
full$in_park <- ifelse(full$in_park, "in_park", "not_in_park")


##### Distance from edge #####
# Next, make just one 'distance from edge' variable
full$dist_from_edge <- ifelse(full$dist_lt40 > 0, full$dist_lt40, full$dist_gt40)
#hist(full$dist_from_edge)
full$log_dist_from_edge <- log(full$dist_from_edge + 1)
#hist(full$log_dist_from_edge)

# Next, say if it's in old, new, or edge of forest.
full <- full |> dplyr::mutate(dist_lt40 = round(dist_lt40, 0),
                              dist_gt40 = round(dist_gt40, 0),
                              age = dplyr::case_when((dist_lt40 == dist_gt40) ~ "on_edge",
                                               (dist_lt40 > dist_gt40) ~ "within_old",
                                               (dist_lt40 < dist_gt40) ~ "within_young"))

```


---

`r paste0(round(sum(pseudo_dens$in_park) / nrow(pseudo_dens) * 100, 0), "%")` of the randomly sampled 'pseudo dens' fall within park lands or protected areas, in contrast to only `r paste0(round(sum(dens$in_park) / nrow(dens) * 100, 0), "%")` of the dens sampled in this study.


```{r pseudo map}
##### Map #####

# Simplify study_area shape - so it plots faster
study_area <- rmapshaper::ms_simplify(study_area)

# Set up our map bounding box
bbox <- st_bbox(study_area)
bbox[1:2] <- bbox[1:2] - 10000 # add a 10km buffer to our bounding box
bbox[3:4] <- bbox[3:4] + 10000 # add a 10km buffer to our bounding box

# Pull BC shapefile from rnaturalearth
bc <- rnaturalearth::ne_states(country = "canada")
bc <- bc[bc$name == "British Columbia", ]
bc <- st_transform(bc, 3005) # BC Albers projection
bc <- st_crop(bc, bbox) # crop to our bounding box area

# Plot time!
ggplot() +
  geom_sf(data = bc, fill = "grey") +
  geom_sf(data = study_area, fill = "#a4a4a4", color = "#4a4a4a") +
  geom_sf(data = parks, fill = "lightgreen", alpha = 0.6) +
  geom_sf(data = full,
          aes(shape = in_park,
              color = type)) +
  scale_color_manual(name = "Data Type",
                     values = c("black", "#de0ae8")) +
  scale_shape(name = "Location", labels = c("In a park/protected area", "Outside a park/protected area")) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_sf(xlim = c(bbox[1], bbox[3]),
           ylim = c(bbox[2], bbox[4])) +
  labs(caption = "In darker grey, the study area. Green indicates Provincial/Federal parks or proteceted areas.") +
  theme(panel.background = element_rect(fill = "transparent",
                                  colour = NA_character_)) # necessary to avoid drawing panel outline
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type, 
             y = prop_forest_60m,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("Pseudo", "Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  labs(x = "Data Type",
       y = "Proportion Forested (GIS verified values)",
       title = "Data Type vs. % Forested (GIS verified)")
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type), 
             y = prop_forest_60m,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  labs(x = "Data Type",
       y = "Proportion Forested (GIS verified values)",
       title = "Data Type vs. % Forested (GIS verified)",
       subtitle = "Comparing values inside vs outside parks/protected areas")
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type, 
             y = dist_lt40,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("Pseudo", "Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to <40 (GIS verified values)",
       title = "Data Type vs. Distance to <40 yo forest (GIS verified values)") 
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type), 
             y = dist_lt40,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to <40 (GIS verified values)",
       title = "Data Type vs. Distance to <40 yo forest (GIS verified values)",
       subtitle = "Comparing values inside vs outside parks/protected areas") 
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type, 
             y = dist_gt40,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("Pseudo", "Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to >40 (GIS verified values)",
       title = "Data Type vs. Distance to >40 yo forest (GIS verified values)") 
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type), 
             y = dist_gt40,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to >40 (GIS verified values)",
       title = "Data Type vs. Distance to >40 yo forest (GIS verified values)",
       subtitle = "Comparing values inside vs outside parks/protected areas") 
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type, 
             y = dist_road,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("Pseudo", "Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to nearest road (GIS verified values)",
       title = "Data Type vs. Distance to nearest road (GIS verified values)") 
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type), 
             y = dist_road,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to nearest road (GIS verified values)",
       title = "Data Type vs. Distance to nearest road (GIS verified values)",
       subtitle = "Comparing values inside vs outside parks/protected areas") 
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type, 
             y = dist_from_edge,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("Pseudo", "Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = "log10") +
  annotation_logticks(side = "l") +
  labs(x = "Data Type",
       y = "log Distance to forest edge (GIS verified values)",
       title = "Data Type vs. Distance to forest edge (GIS verified values)") 
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type), 
             y = dist_from_edge,
             color = type)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")), 
              map_signif_level = TRUE) +
  scale_color_bright() +
  theme_minimal() +
  scale_y_continuous(trans = 'log10') +
  annotation_logticks() +
  labs(x = "Park Status",
       y = "log Distance to forest edge (GIS verified values)",
       title = "Park Status vs. Distance to forest edge (GIS verified values)",
       subtitle = "Comparing values inside vs outside parks/protected areas")
```

---

## Comparing pseudo data to real data

Let's revisit the original figure from a few (dozen) slides ago...

```{r, echo = FALSE, fig.width = 10, fig.height=6, dev.args=list(bg="transparent")}
prop_1km |>  
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 4:12, names_to = "age_class", names_prefix = "age_class_") |>
  dplyr::mutate(age_class = factor(age_class, levels = c(1:9))) |>
  # Then summarize the mean % age class by year 
  dplyr::group_by(year, age_class) |> 
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  labs(title = "Real data age classes") +
  scale_fill_light(reverse = TRUE) +
  theme_minimal()
```

---

## Comparing pseudo data to real data

Zoom in to 2020-2024, so it lines up with pseudo data...

```{r, echo = FALSE, fig.width = 10, fig.height=6, dev.args=list(bg="transparent")}
prop_1km |>  
  # Filter to 2020-2024
  dplyr::filter(year %in% c(2020:2024)) |>
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 4:12, names_to = "age_class", names_prefix = "age_class_") |>
  dplyr::mutate(age_class = factor(age_class, levels = c(1:9))) |>
  # Then summarize the mean % age class by year 
  dplyr::group_by(year, age_class) |> 
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  labs(title = "Real data age classes") +
  scale_fill_light(reverse = TRUE) +
  theme_minimal()
```

---

## Comparing pseudo data to real data

... and compare it to the *very* static age classes around pseudo data.

```{r, echo = FALSE, fig.width = 10, fig.height=6, dev.args=list(bg="transparent")}
pseudo_prct |>  
  # First pivot the data into long format - age class becomes a single column
  tidyr::pivot_longer(cols = 4:12, names_to = "age_class", names_prefix = "age_class_") |>
  dplyr::mutate(age_class = factor(age_class, levels = c(1:9))) |>
  # Then summarize the mean % age class by year 
  dplyr::group_by(year, age_class) |> 
  dplyr::summarise(value = mean(value)) |>
  # Then plot
  ggplot(aes(x = year, y = value, fill = age_class)) +
  geom_area() +
  labs(title = "Pseudo data age classes") +
  scale_fill_light(reverse = TRUE) +
  theme_minimal()
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type,
             y = road_density_m2,
             color = type)) +
  geom_jitter() +
  geom_boxplot(fill = NA) + 
  scale_y_log10() +
  annotation_logticks(side = "l") +
  geom_signif(comparisons = list(c("Pseudo", "Real")),
              map_signif_level = TRUE) +
  scale_color_bright() +
  labs(x = "Data Type",
       y = "Road density",
       title = "Data Type vs. Road Density",
       caption = "m2 of road surface within 1.5 km of the den") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = interaction(in_park, type),
             y = road_density_m2,
             color = type)) +
  geom_jitter() +
  geom_boxplot(fill = NA) + 
  scale_y_log10() +
  annotation_logticks(side = "l") +
  geom_signif(comparisons = list(c("in_park.Pseudo", "not_in_park.Pseudo"),
                                 c("in_park.Real", "not_in_park.Real")),
              map_signif_level = TRUE) +
  scale_color_bright() +
  labs(x = "Data Type",
       y = "Road density",
       title = "Data Type vs. Road Density",
       caption = "m2 of road surface within 1.5 km of the den",
       subtitle = "Comparing values inside vs outside parks/protected areas") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type,
             y = elevation_m,
             color = type)) +
  geom_jitter() +
  geom_boxplot(fill = NA) + 
  geom_signif(comparisons = list(c("Pseudo", "Real")),
              map_signif_level = TRUE) +
  scale_color_bright() +
  labs(x = "Data Type",
       y = "Elevation (m)",
       title = "Data Type vs. Elevation (m)") +
  theme_minimal()
```


---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type,
             y = slope_pct,
             color = type)) +
  geom_jitter() +
  geom_boxplot(fill = NA) + 
  geom_signif(comparisons = list(c("Pseudo", "Real")),
              map_signif_level = TRUE) +
  scale_color_bright() +
  labs(x = "Data Type",
       y = "Slope grade (%)",
       title = "Data Type vs. Slope grade (%)") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

```{r}
full[which(full$den_status %in% for_sure_dens), ] |>
  ggplot(aes(x = type,
             y = slope_aspect,
             color = type)) +
  geom_jitter() +
  geom_boxplot(fill = NA) + 
  geom_signif(comparisons = list(c("Pseudo", "Real")),
              map_signif_level = TRUE) +
  scale_color_bright() +
  labs(x = "Data Type",
       y = "Slope aspect",
       title = "Data Type vs. Slope aspect") +
  theme_minimal()
```

---

## Comparing pseudo data to real data

Takeaways: 
- Randomly sampled points on the landscape are overwhelmingly more likely to have 100% forest coverage within 60 meters than our bear dens.
- The mean distance to recent cutblocks (forest <40 yo) is **significantly higher** for randomly sampled points than for our bear dens.
- For both random data points and bear dens, they are both more likely to be within a patch of mature forest (>40 yo) than not.
- The mean distance to nearest road is **significantly higher** for randomly sampled points than for our bear dens.
- Randomly sampled points, on average, have a higher proportion of old growth forest (age class > 7) within 1.5km than our bear dens.

---

## Comparing pseudo data to real data

Ultimately, I think it's safe to say we *do not* have a random sample of dens, when it comes to both forestry treatments and geography.

---

# Overall data summary

Good news:
- Considering the amount of effort it takes to collect this data, we have a large sample size across a large swath of the province
- This is the first dataset of its kind (to our knowledge)
- We can supplement this data with the huge backlog of camera data

Limitations:
- We don't have a large sample size -> low statistical power
- We don't have much variation between our various variables
- We don't have a representative (random) sample
- Uneven sampling effort across years and regions

---
class: center, middle, inverse

# Our research questions

Now we have had a nice and detailed tour of the data. What are our research questions? What can we try to answer with this data?

---

# Our research questions

In a nutshell:

1. Does the stand condition around the den influence den activity (Active vs. Not active)?
2. Do non-forestry conditions (e.g., den characteristics) influence den activity?
3. Does forestry treatement affect windthrow impacts?
4. Does current management align with recommendations?

---

# Our research questions

In a nutshell:

**1. Does the stand condition around the den influence den activity (Active vs. Not active)?**
2. Do non-forestry conditions (e.g., den size, geography) influence den activity?
3. Does windthrow affect den activity?
4. Does current management align with recommendations?

---
class: center, middle, inverse

# Question 1: Does stand condition affect den activity?

Let's focus on this one.

---

## Question 1

**Question:** How does stand-level condition, including distance to road, proportion forested, and distance to edge, and landscape-level condition (road density, proportion <40 years, proportion >250 years within 1.5km), relate to den use the following winter?

---

## Question 1

**Question:** How does stand-level condition, including distance to road, proportion forested, and distance to edge, and landscape-level condition (road density, proportion <40 years, proportion >250 years within 1.5km), relate to den use the following winter?

**Prediction:** The likelihood of den use over time is positively correlated with distance to <40 years, distance to road, proportion forested, and negatively correlated with distance to >40 years. Landscape condition may have different responses based on condition; at very low road density, and low <40 years, and high >250 years, den use may be less correlated with stand-level condition as we presume more options for bear to use, which means den use may be lower or more sensitive to stand-level variation.

---

## Question 1

Candidate models:

```
den status ~ year                # control for yearly variation in bear activity
den status ~ region              # do dens have different usage by region?
den status ~ proportion forested # do dens with more intact forest have more activity?
den status ~ distance <40        # do dens further from cutblocks have more activity?
den status ~ distance >40        # do dens further from old growth have less activity?
den status ~ distance to road    # do dens further from roads have more activity?
den status ~ road density        # do dens with higher road density have less activity?
den status ~ stand age           # do dens in older stand age have more activity?
den status ~ % old growth        # do dens with higher % old growth nearby have more activity?
den status ~ % new growth        # do dens with higher % new growth nearby have less activity?

# + interactions with stand age
den status ~ distance to road * stand age # does distance to road matter in old vs young stands?
```

---

## Question 1

In addition to these simple one variable models, we also tried a "kitchen sink" approach, with all non-correlated variables within a single model:

```
den status ~ year + region + proportion forested + 
             distance to edge + stand age + 
             road density
```

---

## Question 1

First check for correlation between our model covariates.

---

```{r, out.width="100%"}
# Distance from X variables are all zero inflated and highly skewed.
# Take the log of those variables.
f_analysis$log_dist_lt40 <- log(f_analysis$f_dist_lt40 + 1)
f_analysis$log_dist_gt40 <- log(f_analysis$f_dist_gt40 + 1)
f_analysis$log_dist_road <- log(f_analysis$f_dist_road + 1)

f_analysis |> 
  sf::st_drop_geometry() |>
  dplyr::filter(den_status %in% for_sure_dens) |>
  dplyr::select(den_status_binary, hair_in_bed, region,
                f_prop_forest_60m, log_dist_lt40, log_dist_gt40, log_dist_road,
                log_dist_from_edge, age, year, 
                latitude, longitude,
                windthrow_prct, lt_3, gt_8, road_density_m2) |>
  na.omit() |>
  GGally::ggpairs()
```

---

## Question 1

Data summary: 
- Colinear model terms are excluded from the full "kitchen sink" model.
- Data are strictly filtered down to "Active" and "Not Active" dens where we _for sure_ know the den status. I.e., exluding "Active within past 4 years" or "Unknown" status dens.

---

## Question 1

By far and away, `model00` is consistently the best fit:

```{r}
# The modeling data
dat <- f_analysis[f_analysis$den_status_binary %in% c("Active", "Not Active") & f_analysis$den_status %in% for_sure_dens, ]
dat <- dat[, c("den_status_binary", "den_id", "year", "age", 
               "region", "latitude", "longitude",
               "f_prop_forest_60m", "log_dist_lt40", "log_dist_gt40", "log_dist_road",
               "log_dist_from_edge", "lt_3", "gt_8", "road_density_m2")]
dat <- sf::st_drop_geometry(dat)
dat <- dat[complete.cases(dat),]

# Convert den_status_binary to 0 or 1
dat$den_status_binary <- ifelse(dat$den_status_binary == "Active", 1, 0)

# Let's drop "on_edge" bc it's perfectly == 0 in distance.
#dat <- dat[which(dat$age != "on_edge"),]
# JK - in this case, just categorize it as 'within young' because
# the kitchen sink model was the best fit, and don't wanna show
# NAs in our results summary table.
dat[["age"]][dat$dist_from_edge == 0] <- "within_young"
dat$age <- factor(dat$age, levels = c("within_young", "within_old"))

# Fit the models!
# Just the basics - each forest metric - effectively same as examining boxplots for significance
model00 <- glm(den_status_binary ~ year, data = dat, family = binomial)
model0r <- glm(den_status_binary ~ region, data = dat, family = binomial)
model0a <- glm(den_status_binary ~ f_prop_forest_60m , data = dat, family = binomial)
model0b <- glm(den_status_binary ~ log_dist_lt40 , data = dat, family = binomial)
model0c <- glm(den_status_binary ~ log_dist_gt40 , data = dat, family = binomial)
model0d <- glm(den_status_binary ~ age, data = dat, family = binomial)
model0e <- glm(den_status_binary ~ log_dist_from_edge , data = dat, family = binomial)
model0f <- glm(den_status_binary ~ log_dist_from_edge * age , data = dat, family = binomial)
model0g <- glm(den_status_binary ~ log_dist_road , data = dat, family = binomial)
model0h <- glm(den_status_binary ~ log_dist_road * age , data = dat, family = binomial)
model0i <- glm(den_status_binary ~ gt_8 , data = dat, family = binomial)
model0j <- glm(den_status_binary ~ lt_3 , data = dat, family = binomial)
model0k <- glm(den_status_binary ~ road_density_m2 , data = dat, family = binomial)
model0l <- glm(den_status_binary ~ gt_8 + log_dist_lt40 , data = dat, family = binomial)
model0m <- glm(den_status_binary ~ gt_8 + f_prop_forest_60m , data = dat, family = binomial)
model0n <- glm(den_status_binary ~ road_density_m2 + log_dist_road , data = dat, family = binomial)
model0o <- glm(den_status_binary ~ log_dist_lt40 * region, data = dat, family = binomial)

model1 <- glm(den_status_binary ~ year + region + f_prop_forest_60m + log_dist_from_edge * age + road_density_m2, data = dat, family = binomial)

models_names <- ls()[grep("model0|model1", ls())]
models_list <- lapply(models_names, get)
names(models_list) <- models_names
bbmle::AICtab(models_list, weights = TRUE) # They are all almost identical models in terms of AIC! delta AIC >= 4 == better fit

```

---

## Question 1

`model00` happens to be the base model that simply tries to control for increases in bear den activity as a result of more dens monitored over time...

```{r}
summary(model00)
```

---

## Question 1

`model0` happens to be the base model that simply tries to control for increases in bear den activity as a result of more dens monitored over time...

```{r}
f |> 
  dplyr::mutate(year = lubridate::year(date_inspected)) |>
  ggplot(aes(x = year)) +
  geom_bar() +
  scale_x_continuous(breaks = 2014:2024) +
  labs(x = "Year",
       y = "N field visits",
       title = "Number of field visits per year") +
  theme_minimal() 
```


---

## Question 1

The next-best fit is `model1`, or the full "kitchen sink" model. And, unfortunately, it seems to be the next-best fit model simply because it includes `year` as a parameter. No forestry effects are significant:

```{r}
summary(model1)
```

---

## Question 1

When we go more lenient with our strict data criteria, and decide to include "Active within last 4 years" as "Active", rather than "Unknown", we get nearly identical results. 

---

## Question 1

When we go more lenient with our strict data criteria, and decide to include "Active within last 4 years" as "Active", rather than "Unknown", we get nearly identical results. 

What about modeling the response variable as `hair_in_bed`?

---

## Question 1

When we go more lenient with our strict data criteria, and decide to include "Active within last 4 years" as "Active", rather than "Unknown", we get nearly identical results. 

What about modeling the response variable as `hair_in_bed`?
- It's more objective than the activity status column.
- But, it simply tells us whether or not a bear has visited the den.

---

## Question 1 _ish_

Candidate models:

```
hair in den ~ year                
hair in den ~ region              
hair in den ~ proportion forested 
hair in den ~ distance <40        
hair in den ~ distance >40        
hair in den ~ distance to road    
hair in den ~ road density        
hair in den ~ stand age           
hair in den ~ % old growth        
hair in den ~ % new growth        

# + interactions with stand age
hair in den ~ distance to road * stand age 

# + full model
hair in den ~ year + region + proportion forested + 
              distance to edge + stand age + 
              road density
```

---

## Question 1 _ish_

Results are pretty much the same.... :(

Year is the biggest thing driving any trends (summary of the full model, which also happens to be the best-fit model):

```{r}
# The modeling data
dat <- f_analysis[f_analysis$den_status_binary %in% c("Active", "Not Active") & f_analysis$den_status %in% for_sure_dens, ]
dat <- dat[, c("hair_in_bed", "den_status_binary", "den_id", "year", "age", 
               "region", "latitude", "longitude",
               "f_prop_forest_60m", "log_dist_lt40", "log_dist_gt40", "log_dist_road",
               "log_dist_from_edge", "lt_3", "gt_8", "road_density_m2")]
dat <- sf::st_drop_geometry(dat)
dat <- dat[complete.cases(dat),]

# Convert y to 0 or 1
dat$y <- ifelse(dat$hair_in_bed %in% c("Yes", "Yes - Unchanged"), 1, 0)

# Let's drop "on_edge" bc it's perfectly == 0 in distance.
#dat <- dat[which(dat$age != "on_edge"),]
# JK - in this case, just categorize it as 'within young' because
# the kitchen sink model was the best fit, and don't wanna show
# NAs in our results summary table.
dat[["age"]][dat$dist_from_edge == 0] <- "within_young"
dat$age <- factor(dat$age, levels = c("within_young", "within_old"))

# Fit the models!
# Just the basics - each forest metric - effectively same as examining boxplots for significance
model00 <- glm(y ~ year, data = dat, family = binomial)
model0r <- glm(y ~ region, data = dat, family = binomial)
model0a <- glm(y ~ f_prop_forest_60m , data = dat, family = binomial)
model0b <- glm(y ~ log_dist_lt40 , data = dat, family = binomial)
model0c <- glm(y ~ log_dist_gt40 , data = dat, family = binomial)
model0d <- glm(y ~ age, data = dat, family = binomial)
model0e <- glm(y ~ log_dist_from_edge , data = dat, family = binomial)
model0f <- glm(y ~ log_dist_from_edge * age , data = dat, family = binomial)
model0g <- glm(y ~ log_dist_road , data = dat, family = binomial)
model0h <- glm(y ~ log_dist_road * age , data = dat, family = binomial)
model0i <- glm(y ~ gt_8 , data = dat, family = binomial)
model0j <- glm(y ~ lt_3 , data = dat, family = binomial)
model0k <- glm(y ~ road_density_m2 , data = dat, family = binomial)
model0l <- glm(y ~ gt_8 + log_dist_lt40 , data = dat, family = binomial)
model0m <- glm(y ~ gt_8 + f_prop_forest_60m , data = dat, family = binomial)
model0n <- glm(y ~ road_density_m2 + log_dist_road , data = dat, family = binomial)
model0o <- glm(y ~ log_dist_lt40 * region, data = dat, family = binomial)

model1 <- glm(y ~ year + region + f_prop_forest_60m + log_dist_from_edge * age + road_density_m2, data = dat, family = binomial)

models_names <- ls()[grep("model0|model1", ls())]
models_list <- lapply(models_names, get)
names(models_list) <- models_names
#bbmle::AICtab(models_list, weights = TRUE) # They are all almost identical models in terms of AIC! delta AIC >= 4 == better fit

summary(model1)
```

---

## Question 1: overall summary

- No forestry variables jumped out as significantly influential on den activity status.
- Instead, `year` explained much of the variance - likely because we visited many more dens in later years rather than older years.

Ways forward?
- Perhaps some sort of weights/error structure can account for year without it "swamping" the model?
- Perhaps a bootstrapping approach to account for uneven years sampling: pull a random year of data - one per each den - then fit the model. Do this 1000x. Take the model averages.
- Perhaps running piecewise models: one for 'pre disturbance' den data, one for 'post disturbance'?
- Non-linear modeling approaches: perhaps a principal components analysis (PCA)?
- And finally, and perhaps most likely, we simply **need a greater sample size.** A priori power analysis indicated we'd need >400 dens sampled, but the modeling dataset is only `r nrow(dat)` data points!

---
class: center, middle, inverse

# Question 2: Do non-forestry conditions influence den activity?

---

## Question 2

**Question:** How do intrinsic den characteristics, such as den cavity size and shape, tree species, or position on the slope relate to den use?

---

## Question 2

**Question:** How do intrinsic den characteristics, such as den cavity size and shape, tree species, or position on the slope relate to den use?

**Prediction:** The likelihood of den use is positively correlated with certain den sizes, tree species, and slopes.

---

For all the following plots, the response variable indicates whether or not the den was *ever* active (`ever_active_yn == TRUE`) or has *never* been active (`ever_active_yn == FALSE`). 
This is done to reduce psuedoreplication (many repeats of static den measurements versus changing den status each year), such that there is one data point per den (single static den measurements versus single "was the den active" response).

---

### Chamber dimensions vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r, dev.args=list(bg="transparent")}
label_names <- c(
  `chamber_width` = "Chamber width",
  `chamber_height` = "Chamber height",
  `chamber_length` = "Chamber length"
)

f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(ever_active_yn, chamber_width, chamber_height, chamber_length) |>
  distinct() |>
  tidyr::pivot_longer(cols = c("chamber_width", "chamber_height", "chamber_length"),
                      names_to = "Measurement",
                      values_to = "cm") |>
  ggplot(aes(x = ever_active_yn,
             y = cm,
             color = ever_active_yn)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  ggsignif::geom_signif(comparisons = list(c("FALSE", "TRUE")),
                        map_signif_level = TRUE) +
  hrbrthemes::scale_color_ipsum() +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "transparent", color = NA_character_),
        plot.background = element_rect(fill = "transparent", color = NA_character_),
        text = element_text(size = 20)) + 
  labs(x = "Has the den ever been active?",
       y = "Measurement (cm)") +
  facet_wrap(~ Measurement, labeller = as_labeller(label_names))
```

---

### DBH vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r}
f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(den_tree_dbh, ever_active_yn) |>
  distinct() |>
  ggplot(aes(x = ever_active_yn, 
             y = den_tree_dbh,
             color = ever_active_yn)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  scale_color_bright() +
  geom_signif(comparisons = list(c("TRUE", "FALSE")), map_signif_level = TRUE) +
  theme_minimal() +
  labs(x = "Has the den ever been active?",
       y = "Den Tree DBH (cm)",
       title = "Den Status vs. Den Tree DBH (cm)",
       subtitle = "Binned into dens that have ever vs never been active.",
       caption = paste0("N = ", length(unique(f$den_id)))
       ) 
```

---

### Den type vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

Root bole type dens disproportionately have more activity.

```{r}
chisq <- f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(ever_active_yn, den_type) |>
  distinct() |>
  dplyr::group_by(den_type, ever_active_yn) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = den_type,
                     values_from = n) |>
  tibble::column_to_rownames(var = "ever_active_yn") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

### Den tree species vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

Root bole type dens disproportionately have more activity.

```{r}
chisq <- f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(ever_active_yn, den_tree_species) |>
  distinct() |>
  dplyr::group_by(den_tree_species, ever_active_yn) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = den_tree_species,
                     values_from = n) |>
  tibble::column_to_rownames(var = "ever_active_yn") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

### Bed Cup vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

Active dens disproportionately have a bedding cup (makes sense - it's one of the decision criteria).

```{r}
chisq <- f |>
  dplyr::select(bedding_cup_present, ever_active_yn) |>
  distinct() |>
  dplyr::group_by(bedding_cup_present, ever_active_yn) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = bedding_cup_present,
                     values_from = n) |>
  tibble::column_to_rownames(var = "ever_active_yn") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

### Hair in Bed vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

Active dens disproportionately have hair in the bed (makes sense - it's one of the decision criteria).

```{r}
chisq <- f |>
  dplyr::select(hair_in_bed, ever_active_yn) |>
  distinct() |>
  dplyr::group_by(hair_in_bed, ever_active_yn) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = hair_in_bed,
                     values_from = n) |>
  tibble::column_to_rownames(var = "ever_active_yn") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```

---

### Hair on Entrance vs Den Status

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

Active dens disproportionately have hair on the entrance (makes sense - it's one of the decision criteria).

```{r}
chisq <- f |>
  dplyr::select(hair_on_entrance, ever_active_yn) |>
  distinct() |>
  dplyr::group_by(hair_on_entrance, ever_active_yn) |>
  dplyr::tally() |>
  tidyr::pivot_wider(names_from = hair_on_entrance,
                     values_from = n) |>
  tibble::column_to_rownames(var = "ever_active_yn") |>
  dplyr::mutate_all(~replace(., is.na(.), 0)) |>
  as.matrix() |>
  chisq.test()

corrplot::corrplot(chisq$residuals, is.corr = FALSE)
```


---

### Elevation

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r}
f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(elevation_m, ever_active_yn) |>
  distinct() |>
  ggplot(aes(x = ever_active_yn, 
             y = elevation_m,
             color = ever_active_yn)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  scale_color_bright() +
  geom_signif(comparisons = list(c("TRUE", "FALSE")), map_signif_level = TRUE) +
  theme_minimal() +
  labs(x = "Has the den ever been active?",
       y = "Elevation (m)",
       title = "Den Status vs. Elevation (m)",
       subtitle = "Binned into dens that have ever vs never been active.",
       caption = paste0("N = ", length(unique(f$den_id)))
       ) 
```

---

### Slope grade (%)

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r}
f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(slope_pct, ever_active_yn) |>
  distinct() |>
  ggplot(aes(x = ever_active_yn, 
             y = slope_pct,
             color = ever_active_yn)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  scale_color_bright() +
  geom_signif(comparisons = list(c("TRUE", "FALSE")), map_signif_level = TRUE) +
  theme_minimal() +
  labs(x = "Has the den ever been active?",
       y = "Slope Grade (%)",
       title = "Den Status vs. Slope (%)",
       subtitle = "Binned into dens that have ever vs never been active.",
       caption = paste0("N = ", length(unique(f$den_id)))
       ) 

```

---

### Slope aspect (degrees)

`TRUE` = the den has been active at least one time during the monitoring period.
`FALSE` = the den has never been active during the monitoring period.

```{r}
f |>
  dplyr::left_join(dens, by = "den_id") |>
  dplyr::select(slope_aspect, ever_active_yn) |>
  distinct() |>
  ggplot(aes(x = ever_active_yn, 
             y = slope_aspect,
             color = ever_active_yn)) +
  geom_boxplot(fill = NA) +
  geom_jitter() +
  scale_color_bright() +
  geom_signif(comparisons = list(c("TRUE", "FALSE")), map_signif_level = TRUE) +
  theme_minimal() +
  labs(x = "Has the den ever been active?",
       y = "Slope Aspect",
       title = "Den Status vs. Slope Aspect",
       subtitle = "Binned into dens that have ever vs never been active.",
       caption = paste0("N = ", length(unique(f$den_id)))
       ) 

```

---

## Question 2

Overall, whether or not a den was ever active during the monitoring period does not appear to be significantly influenced by either den qualities (e.g. chamber width, height) or non-forestry geography (e.g., elevation, slope). 


---
class: center, middle, inverse

# Question 3A: Does forestry condition affect windthrow probability?

# Question 3B: Does windthrow severity affect den activity?

---

## Question 3A

**Question:** How does forestry condition, such as distance from cutblock edge, retention patch size, and harvest status influence the amount of windthrow in a given area?

---

## Question 3A

**Question:** How does forestry condition, such as distance from cutblock edge, retention patch size, and harvest status influence the amount of windthrow in a given area?

**Prediction:** The probability of windthrow occuring within a given area will be greater the closer to a cutblock edge that area is. Locations within smaller retention patch sizes and within 60m of harvest are more likely to have windthrow than locations in larger retention patches and futher from harvest.

```{r windthrow prep, include = FALSE}
# This code block preps the dataframe to run Gavin's windthrow 
# analyses. 

# Order the windthrow codes by severity
f$windthrow_code <- factor(f$windthrow_code, 
                           levels = c("None", 
                                      "At risk", 
                                      "Windthrow adjacent (>5%)",
                                      "Windthrow adjacent - catastrophic (>25%)",
                                      "Windthrow block access",
                                      "Den tree top blown",
                                      "Den tree blown over"))

# Create a patch variable that orders forestry treatments
# by patch size + makes shorter labels for plots
f$patch <- factor(f$forestry_treatment_desc,
                  levels = c("Contiguous Forest within >60m radius",
                             "Large retention patch (30-60m radius or 2830-11300 m2)",
                             "Medium retention patch (10-30m radius or 314-2830m2)",
                             "Edge of block (within 5m)",
                             "Other"),
                  labels = c("Contiguous",
                             "Large RP",
                             "Med. RP",
                             "Edge (<5 m)",
                             "Other"))

# Create a harvested varianle
f$harvested <- ifelse((f$f_prop_forest_60m < 100 & (f$f_dist_lt40 <= 60 | f$f_dist_road <= 60)),
                      "Harvested",
                      "Not harvested")
f$harvested_yn <- ifelse(f$harvested == "Harvested",
                         TRUE,
                         FALSE)

# Categorize windthrow codes into severity categories
f <- f |>
  dplyr::mutate(windthrow_sev = dplyr::case_when(windthrow_code == "None" ~ "Insignificant",
                                                 windthrow_code == "At risk" ~ "At risk",
                                                 windthrow_code == "Windthrow adjacent (>5%)" ~ "Moderate",
                                                 windthrow_code %in% c("Windthrow adjacent - catastrophic (>25%)",
                                                                       "Windthrow block access",
                                                                       "Den tree top blown",
                                                                       "Den tree blown over") ~ "Severe",
                                                 TRUE ~ NA))

f$windthrow_sev <- factor(f$windthrow_sev,
                          levels = c("Insignificant",
                                     "At risk",
                                     "Moderate",
                                     "Severe"))

# NOTE THIS IS DIFFERENT TO THE `distance_from_edge` VARIABLE
# CREATED ELSEWHERE IN THIS DOCUMENT
# The previous analysis lumped together distance from edge
# to <40 yo forest and distance to road. They were both
# considered 'disturbed' forest edges susceptible to windthrow.

# Choose whichever one is the lower value
f$dist_to_edge <- ifelse(f$f_dist_lt40 < f$f_dist_road,
                         f$f_dist_lt40,
                         f$f_dist_road)
```

---

Windthrow is categorized by estimating the proportion of trees within a 60m radius of a given point (lat, lon of a den) that are windthrown.

```{r}
ggplot(f,
       aes(x = windthrow_code)) +
  geom_bar() +
  labs(x = "Windthrow Code",
       y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

---

Windthrow is categorized by estimating the proportion of trees within a 60m radius of a given point (lat, lon of a den) that are windthrown.

```{r}
summary(f$windthrow_prct)

ggplot(f,
       aes(x = windthrow_prct)) +
  geom_density() +
  labs(x = "Windthrow (%)",
       y = "Density") +
  scale_x_continuous(limits = c(0, 100)) +
  theme_minimal()
```

---

Windthrow is categorized by estimating the proportion of trees within a 60m radius of a given point (lat, lon of a den) that are windthrown.

```{r}
f[!is.na(f$patch), ] |>
  ggplot(aes(x = patch,
             y = windthrow_prct)) +
  geom_jitter() +
  geom_boxplot(fill = NA) +
  labs(x = "Patch size (category)",
       y = "Windthrow (%)") +
  scale_y_continuous(limits = c(0, 100)) +
  theme_minimal()
```

---

Harvest status is determined by the % tree coverage within 60m of a given point. If a road cuts through the forest OR there is forest <40 years old within 60m of that point, it counts as "harvested". Areas within 60m naturally unforested areas, such as the edge of a lake, would NOT count as "harvested" under these critera.

```{r}
ggplot(f[!is.na(f$harvested), ],
       aes(x = harvested)) +
  geom_bar() +
  labs(x = "Harvest status", 
       y = "Count") +
  theme_minimal()
```

---

Harvested areas have significantly higher % windthrow.

```{r}
f[!is.na(f$harvested), ] |>
  ggplot(aes(x = harvested,
           y = windthrow_prct)) +
  geom_jitter() +
  geom_boxplot(fill = NA) +
  geom_signif(comparisons = list(c("Harvested", "Not harvested")),
              map_signif_level = TRUE,
              test = "wilcox.test") +
  labs(x = "Harvest status", 
       y = "Windthrow (%)") +
  theme_minimal()
```

---

Distance to edge is the distance to any hard forest edge caused by harvest activity, including distance to <40 yo forest or distance to road (whichever was closer).

```{r}
ggplot(f[which(f$dist_to_edge < 6000), ],
       aes(x = dist_to_edge,
           y = windthrow_prct)) +
  #scale_x_log10() +
  scale_y_continuous(limits = c(0, 100)) +
  geom_point() + 
  labs(title = "Distance to Edge vs Windthrow (%)",
       x = "Distance to Edge",
       y = "Windthrow (%)") +
  theme_minimal()
```

---

```{r}
dat <- f[,c("windthrow_prct", "dist_to_edge")]
dat <- na.omit(dat)
dat$dist_to_edge <- log(dat$dist_to_edge + 1)
dat <- dat[dat$dist_to_edge < 6000, ]
dat <- unique(dat) # Remove all the duplicates

# It's not perfect, but it'll work for the plot
tw <- glmmTMB(formula = windthrow_prct ~ dist_to_edge,
               data = dat,
               family = tweedie)
#tw_preds <- predict(tw, dat, type = "response")
ilink <- family(tw)$linkinv   # this is the inverse of the link function, as an R function
pdata <- cbind(dat[,c("windthrow_prct", "dist_to_edge")],
               as.data.frame(predict(tw, newdata = dat, type = "link", se.fit = TRUE)))
## Compute 95% confidence interval on link scale & back transform this & model fit to response scale
pdata <- transform(pdata,
                   upper  = ilink(fit + (1.96 * se.fit)),
                   lower  = ilink(fit - (1.96 * se.fit)),
                   fitted = ilink(fit))


pdata |>
  dplyr::mutate(dist_to_edge = exp(dist_to_edge) - 1) |>
  ggplot(aes(x = dist_to_edge)) +
  geom_point(aes(y = windthrow_prct),
             color = "black",
             alpha = 0.5,
             shape = 4) + 
  geom_ribbon(aes(ymin = lower,
                  ymax = upper),
              alpha = 0.2) +
  geom_line(aes(y = fitted), color = "red") +
  coord_cartesian(xlim = c(0, 1000)) +
  scale_y_continuous(limits = c(0, 100)) +
  labs(title = "Distance to Edge vs Windthrow (%)",
       x = "Distance to Edge",
       y = "Windthrow (%)") +
  theme_minimal()
```

---

```{r}
summary(tw)
```

---

While there is a relationship between windthrow % and distance to edge, there appears to be no relationship between forest stand age class and windthrow (there were no significant differences between finer groupings of age class, either). 

```{r}
f |>
  dplyr::filter(!is.na(age_class)) |>
  dplyr::mutate(age_class = ifelse(age_class == "9: >250",
                                   ">9 (Old growth)",
                                   "<9 (all other stages)")) |>
  ggplot(aes(x = age_class,
             y = windthrow_prct)) +
  geom_jitter() +
  geom_boxplot(fill = NA) +
  geom_signif(comparisons = list(c(">9 (Old growth)", "<9 (all other stages)")),
              map_signif_level = TRUE,
              test = "wilcox.test") +
  labs(x = "Age Class",
       y = "Windthrow (%)") +
  theme_minimal()
```

---

There is a significant relationship between canopy closure and windthrow.

```{r}
ggplot(f,
       aes(x = canopy_closure,
           y = windthrow_prct)) +
  geom_point() +
  stat_smooth(method = "lm") +
  scale_x_continuous(limits = c(0, 100)) +
  labs(x = "Canopy closure (%)",
       y = "Windthrow (%)") +
  theme_minimal()
```

---

There is a significant relationship between canopy closure and windthrow.

```{r}
summary(lm(windthrow_prct ~ canopy_closure, data = f))
```

---

## Question 3B

**Question:** How does windthrow severity influence den activity? 

---

## Question 3B

**Question:** How does windthrow severity influence den activity? 

**Prediction:** Dens within areas of higher windthrow severity are less likely to be active.

---

## Question 3B: Analyses TBD!

---
class: center, middle, inverse

# Question 4: Does current management align with recommendations?

How many dens fall within best practice guidelines?

---

### Dens >75m from the nearest road

```{r}
n_dens <- length(unique(f$den_id))
  
f |>
  dplyr::select(den_id, f_dist_road) |>
  dplyr::filter(!is.na(f_dist_road)) |>
  dplyr::distinct() |>
  dplyr::mutate(over_75 = f_dist_road > 75) |>
  #dplyr::group_by(over_75) |>
  #dplyr::summarize(n_over_75 = dplyr::n()) |>
  ggplot(aes(x = over_75)) +
  geom_bar() +
  labs(title = "N dens >75m from a road",
          x = "Is the den >75m from a road?",
          y = "N dens",
       caption = paste(n_dens, "dens total")) +
  theme_minimal()
```

---

### Dens >75m from the nearest road

```{r}
f |>
  dplyr::select(den_id, den_status_binary, f_dist_road) |>
  dplyr::filter(!is.na(f_dist_road)) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::distinct() |>
  dplyr::mutate(over_75 = f_dist_road > 75) |>
  #dplyr::group_by(over_75) |>
  #dplyr::summarize(n_over_75 = dplyr::n()) |>
  ggplot(aes(x = over_75,
             fill = den_status_binary)) +
  geom_bar() +
  scale_fill_bright(name = "Den status") +
  labs(title = "N dens >75m from a road",
       x = "Is the den >75m from a road?",
       y = "N dens",
       caption = paste(n_dens, "dens total")) +
  facet_wrap(~ den_status_binary) +
  theme_minimal()
```

---

### Dens >30m from cutblock/new growth

```{r}
f |>
  dplyr::select(den_id, f_dist_lt40) |>
  dplyr::filter(!is.na(f_dist_lt40)) |>
  dplyr::distinct() |>
  dplyr::mutate(over_30 = f_dist_lt40 > 30) |>
  ggplot(aes(x = over_30)) +
  geom_bar() +
  labs(title = "N dens >30m from a cutblock",
       x = "Is the den >30m from a cutblock (forest <40 years old)?",
       y = "N dens",
       caption = paste(n_dens, "dens total")) +
  theme_minimal()
```

---

### Dens >30m from cutblock/new growth

```{r}
f |>
  dplyr::select(den_id, den_status_binary, f_dist_lt40) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::filter(!is.na(f_dist_lt40)) |>
  dplyr::distinct() |>
  dplyr::mutate(over_30 = f_dist_lt40 > 30) |>
  ggplot(aes(x = over_30,
             fill = den_status_binary)) +
  geom_bar() +
  scale_fill_bright(name = "Den status") +
  facet_wrap(~ den_status_binary) +
  labs(title = "N dens >30m from a cutblock",
       x = "Is the den >30m from a cutblock (forest <40 years old)?",
       y = "N dens",
       caption = paste(n_dens, "dens total")) +
  theme_minimal()
```

---

### Dens with 100% forest retention in a 60m radius

```{r}
f |>
  dplyr::select(den_id, f_prop_forest_60m) |>
  dplyr::filter(!is.na(f_prop_forest_60m)) |>
  dplyr::distinct() |>
  dplyr::mutate(allforest = f_prop_forest_60m == 100) |>
  ggplot(aes(x = allforest)) +
  geom_bar() +
  labs(title = "N dens 100% forested within 60m",
       x = "Is the den 100% forested in a 60m radius?",
       y = "N dens",
       caption = paste(n_dens, "dens total")) +
  theme_minimal()
```

---

### Dens with 100% forest retention in a 60m radius

```{r}
f |>
  dplyr::select(den_id, den_status_binary, f_prop_forest_60m) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::filter(!is.na(f_prop_forest_60m)) |>
  dplyr::distinct() |>
  dplyr::mutate(allforest = f_prop_forest_60m == 100) |>
  ggplot(aes(x = allforest,
             fill = den_status_binary)) +
  geom_bar() +
  scale_fill_bright(name = "Den status") +
  facet_wrap(~ den_status_binary) +
  labs(title = "N dens 100% forested within 60m",
       x = "Is the den 100% forested in a 60m radius?",
       y = "N dens",
       caption = paste(n_dens, "dens total")) +
  theme_minimal()
```

---

### Dens within each patch size class

```{r}
n_dens <- length(unique(f[["den_id"]][!is.na(f$forestry_treatment_desc)]))
f |>
  dplyr::select(den_id, den_status_binary, forestry_treatment_desc) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::filter(!is.na(forestry_treatment_desc)) |>
  dplyr::distinct() |>
  ggplot(aes(x = forestry_treatment_desc)) +
  geom_bar() +
  scale_fill_bright(name = "Den status") +
  labs(title = "N dens by patch size",
       x = "Patch status",
       y = "N dens",
       caption = paste(n_dens, "dens total with enough information to determine patch size")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  coord_flip()
```

---

### Dens within each patch size class

```{r}
f |>
  dplyr::select(den_id, den_status_binary, forestry_treatment_desc) |>
  dplyr::filter(den_status_binary %in% c("Active", "Not Active")) |>
  dplyr::filter(!is.na(forestry_treatment_desc)) |>
  dplyr::distinct() |>
  ggplot(aes(x = forestry_treatment_desc,
             fill = factor(den_status_binary))) +
  geom_bar(position = "dodge") +
  scale_fill_bright(name = "Den status") +
  labs(title = "N dens by patch size",
       x = "Patch status",
       y = "N dens",
       caption = paste(n_dens, "dens total with enough information to determine patch size")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  coord_flip()
```


